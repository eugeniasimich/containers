\begin{code}
module Container where

open import Data.Bool
open import Data.Nat
open import Data.Fin hiding (_+_)
open import Data.Unit
open import Data.Product hiding (map)
open import Data.Sum hiding (map)
open import Data.Empty
open import Function renaming (_∘_ to _∘ₛ_ ; id to idₛ)
open import Relation.Binary.HeterogeneousEquality hiding ([_])
\end{code}


%<*cont>
\begin{code}
record Cont : Set₁ where
  constructor _◃_
  field
    Sh  : Set 
    Pos : Sh → Set 
\end{code}
%</cont>

\begin{code}
open Cont
\end{code}

%<*ext>
\begin{code}
⟦_⟧ : Cont → Set → Set 
⟦ S ◃ P ⟧ X = Σ[ s ∈ S ] (P s → X)
\end{code}
%</ext>

\begin{code}
map : ∀{X Y C} → (f : X → Y) → ⟦ C ⟧ X → ⟦ C ⟧ Y
map f (s , p) = s , (f ∘ₛ p)
\end{code}


%<*clist>
\begin{code}
cList : Cont
cList = ℕ ◃ Fin
\end{code}
%</clist>

%<*listconstructors>
\begin{code}
nil : ∀{X} → ⟦ cList ⟧ X
nil = 0 , (λ ())

cons : ∀{X} → X → ⟦ cList ⟧ X → ⟦ cList ⟧ X
cons x (n , f) = ( suc n , (λ  { zero     → x
                               ; (suc i)  → f i }) )
\end{code}
%</listconstructors>

%<*cId>
\begin{code}
cId : Cont
cId = ⊤ ◃ (λ _ → ⊤)
\end{code}
%</cId>

%<*Id>
\begin{code}
identity : ∀{X} → X → ⟦ cId ⟧ X
identity x = tt , (λ _ → x)
\end{code}
%</Id>

%<*cK>
\begin{code}
cK : Set → Cont
cK A = A ◃ (λ _ → ⊥)
\end{code}
%</cK>

%<*K>
\begin{code}
K : Set → Set → Set
K A = ⟦ cK A ⟧
\end{code}
%</K>

%<*dos>
\begin{code}
dos : ⟦ cK ℕ ⟧ ⊥
dos = 2 , (λ { () })
\end{code}
%</dos>

%<*cMaybe>
\begin{code}
cMaybe : Cont
cMaybe = Bool ◃ (λ  { false  → ⊥
                    ; true   → ⊤ }) 
\end{code}
%</cMaybe>

%<*maybe>
\begin{code}
nothing : ∀{X} → ⟦ cMaybe ⟧ X
nothing = false , (λ { () })

just : ∀{X} → X → ⟦ cMaybe ⟧ X
just x = true , (λ { tt → x })
\end{code}
%</maybe>

%<*cStream>
\begin{code}
cStream : Cont
cStream = ⊤ ◃ (λ {tt → ℕ})
\end{code}
%</cStream>

%<*Stream>
\begin{code}
s : ⟦ cStream ⟧ ℕ
s = tt , (λ _ → 1)
\end{code}
%</Stream>


%<*cReader>
\begin{code}
cReader : Set → Cont
cReader E = ⊤ ◃ (λ {tt → E})
\end{code}
%</cReader>

%<*reader>
\begin{code}
Reader : Set → Set → Set
Reader E = ⟦ cReader E ⟧ 

reader : ∀{E X} → (E → X) → Reader E X
reader x = tt , x
\end{code}
%</reader>


%<*treeSh>
\begin{code}
data TreeSh : Set where
  leafSh : TreeSh
  nodeSh : TreeSh → TreeSh → TreeSh
\end{code}
%</treeSh>


%<*treePos>
\begin{code}
data TreePos : TreeSh → Set where
  leafPos : TreePos leafSh
  nodePosL : ∀{l r} → TreePos l → TreePos (nodeSh l r)  
  nodePosR : ∀{l r} → TreePos r → TreePos (nodeSh l r)  
\end{code}
%</treePos>


%<*ctree>
\begin{code}
cTree : Cont
cTree = TreeSh ◃ TreePos
\end{code}
%</ctree>
x
%<*tree>
\begin{code}
Tree : Set → Set
Tree = ⟦ cTree ⟧

leaf : ∀{X} → X →  ⟦ cTree ⟧ X
leaf x = leafSh , (λ { leafPos → x })

node : ∀{X} → ⟦ cTree ⟧ X → ⟦ cTree ⟧ X → ⟦ cTree ⟧ X
node (sl , pl) (sr , pr) = nodeSh sl sr , (λ  { (nodePosL pos) → pl pos
                                              ; (nodePosR pos) → pr pos })
\end{code}
%</tree>

%<*morph>
\begin{code}
record _⇒_ (C₁ C₂ : Cont) : Set where
  constructor _,_
  field
    mSh  : Sh C₁ → Sh C₂
    mPos : ∀{s : Sh C₁} → Pos C₂ (mSh s) → Pos C₁ s
\end{code}
%</morph>

\begin{code}
infixr 4 _⇒_
open _⇒_
\end{code}

%<*morphExt>
\begin{code}
⟦_⟧ₘ : ∀{C D} → (C ⇒ D) → ∀{X} → ⟦ C ⟧ X → ⟦ D ⟧ X
⟦ f ⟧ₘ ( c , fp ) = (mSh f c) , (fp ∘ₛ mPos f {c})
\end{code}
%</morphExt>



%<*either>
\begin{code}
Either : Cont → Cont → Cont
Either C D = (Sh C ⊎ Sh D) ◃ [ Pos C , Pos D ]
\end{code}
%</either>

%<*inj1>
\begin{code}
ι₁ : ∀{C D} → C ⇒ Either C D
ι₁ = inj₁ , idₛ
\end{code}
%</inj1>

\begin{code}
ι₂ : ∀{C D} → D ⇒ Either C D
ι₂ = inj₂ , idₛ
\end{code}

%<*Producto>
\begin{code}
Both : Cont → Cont → Cont
Both C D = (Sh C × Sh D) ◃ (λ { (c , d) → Pos C c ⊎ Pos D d })
\end{code}
%</Producto>

%<*proj1t>
\begin{code}
Π₁ : ∀{C D} → (Both C D) ⇒ C
\end{code}
%</proj1t>

%<*proj1d>
\begin{code}
Π₁ = proj₁ , inj₁
\end{code}
%</proj1d>
