\chapter*{Introducci\'on}
\addcontentsline{toc}{chapter}{Introducci\'on}

\begin{epigraphs}
\qitem{
  El otro proyecto era un plan para abolir por completo todas las palabras, cualesquiera que fuesen; y se defendía como una gran ventaja, tanto respecto de la salud como de la brevedad. Es evidente que cada palabra que hablamos supone, en cierto grado, una disminución de nuestros pulmones por corrosión, y, por lo tanto, contribuye a acortarnos la vida; en consecuencia, se ideó que, siendo las palabras simplemente los nombres de las cosas, sería más conveniente que cada persona llevase consigo todas aquellas cosas de que fuese necesario hablar en el asunto especial sobre que había de discurrir.\\
  %Y este invento se hubiese implantado, ciertamente, con gran comodidad y ahorro de salud para los individuos, de no haber las mujeres, en consorcio con el vulgo y los ignorantes, amenazado con alzarse en rebelión si no se les dejaba en libertad de hablar con la lengua, al modo de sus antepasados; que a tales extremos llegó siempre el vulgo en su enemiga por la ciencia. Sin embargo,
  (...) muchos de los más sabios y eruditos se adhirieron al nuevo método de expresarse por medio de cosas: lo que presenta como único inconveniente el de que cuando un hombre se ocupa en grandes y diversos asuntos se ve obligado, en proporción, a llevar a espaldas un gran talego de cosas.}{Los Viajes de Gulliver\\ Jonathan Swift}
\end{epigraphs} 

Sin dudas, en un mundo como el que plantea el exergo, las ciencias de la computación no tendrían lugar. La historia de esta disciplina está conformada, en gran parte, de sucesivos intentos de formalizar el razonamiento. Como resultado se obtuvo la posibilidad de crear cosas con palabras, y la posibilidad de elegir qué cosas creamos a partir de enriquecer o limitar el lenguaje utilizado.

En ese sentido, este trabajo no es la excepción, puesto que a grandes rasgos trabajaremos con el objetivo de formalizar una serie de construcciones que, por su parte, funcionan como un lenguaje para expresar de forma alternativa ciertos constructores de tipos de datos.

Los {\it containers}~\cite{abbott:thesis,abbott:2003} se presentan como una opción de representación de un conjunto de tipos de datos paramétricos, aquellos que pueden ser pensados como estructuras, esqueletos para contener otros datos. Segregando estructura de contenido, esta forma de representación posibilita el análisis aislado de la estructura.

Se conoce como paradigma de programación genérica~\cite{generic} a aquella disciplina que problematiza, entre otras cuestiones, la construcción de algoritmos cuyos argumentos puedan pertenecer no solo a un tipo de datos particular, sino a un conjunto amplio. Entre sus objetivos se encuentran el ahorrar código y favorecer la claridad, expandiendo las posibilidades de parametrización. En este sentido, al identificar a un extenso grupo de tipos de datos, los containers promueven el análisis abstracto y se postulan como una buena alternativa hacia la construcción de programas genéricos~\cite{alti:2007}.

Para comenzar, se realizará un repaso amplio del contexto histórico de esta disciplina, haciendo énfasis particular en algunos puntos con mayor relevancia para este trabajo.

\section*{Un siglo de historia en 1400 palabras (incluidas estas tres)}%10

Hacia finales de siglo XIX y principios del XX, la matemática estaba pasando por una etapa predominantemente formalista. Muchos estudiosos de la época veían la necesidad de refundar toda la matemática sobre una base axiomática en la que se pudieran probar formalmente, dentro del sistema, todos los teoremas posibles. Más aún, estaban los que opinaban que la matemática era reducible a la lógica, siendo toda verdad matemática una verdad lógica. Uno de los primeros intentos de llevar a la práctica estas ideas, si bien de gran influencia posterior, será célebre por un error. Gottlob Frege publica {\it Begriffsschrift}~\citeIntro{frege:1879} en 1879, donde presenta un sistema formal para la lógica de predicados. Este estaba pensado no solo como modelo de la aritmética, sino que Frege va más allá y lo propone como modelo del pensamiento y posible instrumento para filósofos.

Veinte años más tarde, Bertrand Russell encuentra un problema en el sistema de Frege y le escribe una carta. Se trataba de lo que hoy se conoce como la paradoja de Russell, que se resume en la posibilidad de definir un conjunto, llamémosle $R$, tal que $$s \in R \Leftrightarrow s \notin s$$ En particular, substituyendo $R$ por $s$, obtenemos la siguiente inconsistencia $$R \in R \Leftrightarrow R \notin R$$
La impredicatividad, es decir, la posibilidad de definir predicados cuantificados sobre un conjunto al que el predicado pertenece, es una característica que puede traer paradojas de esta índole.

A pesar del tropiezo, el impulso formalista continúa. Russell junto con Whitehead se proponen seguir el legado de Frege y publican entre 1910 y 1913 un tratado de tres volúmenes llamado {\it Principia Mathematica}~\citeIntro{PM:10}. Allí postulan un sistema tan preciso como difícil de ser llevado a cabo, a tal punto que la formulación de $1 + 1 = 2$ aparece recién en el segundo volumen y su prueba, en el tercero. Sin embargo, fue muy bien aceptado por la comunidad científica, instaurando aún más la idea de que la formalización lógica de la matemática era posible. El objetivo era ahora lograr derivar toda la matemática y probar toda proposición verdadera dentro de la formalización de los {\it Principia}.

En esta escena es donde aparece Kurt Gödel a traer malas noticias. En 1931, con su primer teorema de incompletitud~\citeIntro{godel:1931}, demuestra que en cualquier sistema consistente, tan poderoso como el de los {\it Principia}, donde se pudiera modelar aritmética básica, existen juicios trivialmente verdaderos que resultan ser imposibles de demostrar. Es decir, demuestra que no se puede tener completitud y consistencia a la vez.

Segundo traspié y los deseos formalistas empiezan a ser un poco más conservadores. ¿Podremos tener al menos un mecanismo de decisión que diga si un juicio es o no demostrable? Es decir, ¿existe un {\it algoritmo} que decida si una fórmula es o no un teorema? A esta pregunta se la conoce como el {\it problema de la decisión}, traducción del vocablo alemán {\it Entscheidungsproblem}~\citeIntro{hilbert:1928}. La respuesta fue otra vez por la negativa. De forma independiente, Alonzo Church en 1936~\citeIntro{church:1936} y muy pocos meses después Alan Turing~\citeIntro{turing:1936}, proponen modelos de computación --el lambda cálculo y las máquinas de Turing, respectivamente-- y demuestran la imposibilidad de construir dicho algoritmo en sus sistemas. Turing, por su parte, también prueba la equivalencia de su sistema con el previamente propuesto por Church y lo publica de todas formas, ya que resultan ser lo suficientemente diferentes en cuanto a lo que filosofía se refiere~\citeIntro{wadler:2015}. La formulación de Turing preveía la posibilidad de la existencia de máquinas de computar, mientras que la formulación de Church fue originalmente pensada como una nueva notación para la lógica.

Hasta ahora podemos concluir que cada tropiezo trajo consigo sus frutos. En este caso, de la respuesta al Entscheidungsproblem nacen la formulación de los primeros lenguajes de computación y la noción de lo {\it efectivamente calculable}. Una función es efectivamente calculable si puede ser formulada como un término del lambda cálculo, o equivalentemente, como un procedimiento en la máquina de Turing.

El desarrollo de la lógica, la matemática y este nuevo estudio de lo computable, continuó. Dentro del ámbito de la primera, Gerhard Gentzen introduce la deducción natural~\citeIntro{gentzen:untls}, entre muchas otras formulaciones y estilos de notación que perduran hoy en día. Por el lado de las ciencias de la computación, Kleene y Rosser, alumnos de Church, encuentran un problema en el lambda cálculo~\citeIntro{kleenerosser}. Así como la impredicatividad del sistema propuesto por Frege traía aparejada la inconsistencia del sistema, en el caso del lambda cálculo, la posibilidad de aplicar funciones a sí mismas significaba tener algoritmos que no terminasen. Esto podía ser o no un problema, pero con la intención de poder asegurar la terminación de las funciones, Church hace uso de una solución equivalente a la de Russell y agrega tipos al lambda cálculo~\citeIntro{church:types}, asegurando su terminación. Por el lado de la matemática, hacia la década del 40, Samuel Eilenberg y Saunders Mac Lane introducen nociones fundantes de la nueva teoría de categorías~\citeIntro{maclane}, como ser la noción de categoría, funtor y transformación natural como parte de su trabajo en topología algebraica. 

En 1934, Haskell Curry observa un hecho curioso relativo al tipo funcional $A \to B$ y la implicación $A \supset B$; cada función de dicho tipo  podía ser entendida como la prueba de la implicancia. Es así como Curry, junto con Robert Feys publican esta idea en sus trabajos sobre lógica combinatoria~\citeIntro{curryfeys}, donde se hace explícita la correspondencia entre tipos y proposiciones, pruebas y funciones. Tiempo más tarde, finalizando la década del 60, motivado por estas observaciones, William Howard~\citeIntro{howard}, alumno de Mac Lane, encuentra una correspondencia entre pruebas en deducción natural y programas en lambda cálculo simplemente tipado, agregando que la normalización de pruebas en deducción natural se corresponde con la beta reducción del cálculo lambda. Además, incluye otras correspondencias estructurales como ser la del producto y la conjunción lógica o la unión disjunta y la disyunción. Esta correspondencia se conoce hoy en día como el isomorfismo de Curry-Howard. Esta correlación ya había sido vislumbrada por los lógicos intuicionistas Brower, Heyting e independientemente por Kolmogorov, aunque no ligándola de forma explícita con el lambda cálculo.

Sería también un lógico intuicionista, el sueco Per Martin Löf, el que encontraría en estas ideas la inspiración para la formulación de la teoría de tipos intuicionista, base de muchos lenguajes de programación/asistentes de prueba como lo es Agda, lenguaje que utilizaremos en este trabajo; o también {\it Epigram}~\cite{mcbride:epigram}, {\it Idris}~\cite{brady:idris,idris} y {\it Coq}~\cite{coq}.
Hacia 1971 el ámbito científico ya conoce un primer manuscrito de Per Martin-Löf donde describe su teoría de tipos intuicionista, fuertemente influenciado por los trabajos de Curry y Feys. En ese manuscrito, Martin Löf expone una teoría de tipos dependientes con la intención de utilizar la lógica como fundamento de las matemáticas, continuando con las intenciones formalistas de principios de siglo.

Una de las modificaciones que se realizarían a ese primer manuscrito nunca publicado es la introducción de universos de tipos.
La teoría de tipos en esa primera versión incluía un universo $V$ al que pertenecían todos los tipos de datos, incluyendo el axioma $V \in V$. Es decir, el axioma asevera que el tipo de datos que aglutina a todos los tipos de datos, también es un tipo de datos.  En su tesis doctoral, Jean-Yves Girard demuestra que este axioma introduce una inconsistencia~\citeIntro{girard:thesis}, producto de una paradoja similar a la paradoja de Russell. Para evitar este problema, se introduce a la teoría una jerarquía de universos~\citeIntro{Martin-Lof-1972}, tomando de la teoría de categorías la idea de categorías pequeñas y categorías grandes. El universo $V$ será entonces, el universo al que pertenecen los {\it tipos pequeños}. El elemento $V$ en sí y todos los tipos construidos a partir de él, pertenecerán al siguiente nivel, $V_1$. Queda así establecida una jerarquía de universos: $$V = V_0 \in V_1 \in \ldots \in V_n \in \ldots$$
Si bien la introducción de universos en la teoría de tipos fue necesaria para mantener la consistencia del sistema, es un recurso muy útil si buscamos parametricidad en funciones y tipos o programar genéricamente.

También a comienzos de la década del 70 aparecería un resultado que uniría la lógica y las ciencias de la computación con la teoría de categorías de una forma muy interesante. Joachim Lambek~\citeIntro{lambek:1972} muestra que el isomorfismo de Curry-Howard tiene una tercera pata: las categorías cartesianas cerradas muestran una correspondencia ecuacional con la lógica y el lambda cálculo tipado, siendo posible interpretar a los tipos (o proposiciones) como objetos de la categoría y a los términos (o pruebas) como los morfismos.
Es por dicha razón que en la actualidad muchos se refieren a la correspondencia expuesta como de {\it Curry–Howard–Lambek}.


\subsection*{Estado del arte}

Los containers son concebidos por Abbott, Altenkirch y Ghani en 2003, en un primer trabajo denominado {\it Categories of Containers}~\cite{abbott:2003} y profundizado luego en la tesis doctoral del primero~\cite{abbott:thesis}. Allí, exponen una formalización matemática de los containers, entendiéndolos como una forma de representar aquellos tipos de datos que consisten en {\it plantillas} a llenar con otros datos. Muestran también que los containers resultan ser cerrados bajo una serie de construcciones; en particular, prueban que es posible representar a todos los tipos estrictamente positivos. Asimismo, introducen la extensión de los containers como una forma de reinterpretarlos como constructores funtoriales de tipos de datos. Siguiendo esta línea, presentan lo que llamaremos morfismos de containers como el conjunto de funciones polimórficas entre estos tipos de datos, que categóricamente hablando resultan ser las transformaciones naturales entre los funtores asociados.

En el trabajo {\it Higher Order Containers}, Altenkirch, Levy y Staton~\cite{alti:2010} exponen, entre otros resultados, la existencia de exponenciales para todo par de containers, convirtiendo a la categoría en cartesiana cerrada. A pesar de que la categoría de containers fue en un principio pensada como modelo para tipos de datos, este resultado implica que también se puedan interpretar construcciones de alto orden. 

En los trabajos recientemente mencionados se prueba adicionalmente que los containers --ampliando la formulación para representar constructores con múltiples argumentos-- son cerrados bajo álgebra inicial y coálgebra final, convirtiéndolos en una buena alternativa de semántica composicional. En particular, resultan ser un buen modelo semántico para los denominados tipos estrictamente positivos.

Luego de introducir el universo de containers y realizar aportes relacionados, como ser la exposición de sus exponenciales, Altenkirch {\it et al.} presentan los containers indexados~\cite{alti:2015}, una generalización que pasa de representar tipos de datos a familias de tipos, haciendo énfasis particular en la utilización de los containers indexados como modelo de las familias estrictamente positivas. Como punto de vista alternativo a un mismo objeto de estudio se pueden citar los trabajos acerca de funtores polinomiales~\cite{kock2010} realizados por Kock y Gambino.

También en lo que refiere a semántica de tipos de datos, los {\it shapely types} --i.e. tipos con forma-- son introducidos por Jay y Cockett~\cite{jay94,jay95}. Estos muestran una conexión interesante puesto que su construcción se basa en una segregación de estructura y contenido, igual que el universo que se analiza en el presente trabajo. Puede demostrarse que todo shapely type es factible de ser representado como container.

Remontándonos más en el tiempo se puede encontrar otro trabajo relacionado que vale mencionarse: es el que refiere a las denominadas especies combinatorias, originalmente propuestas por Joyal en los años 80~\cite{joyal1981}. Para ese momento, la teoría sobre tipos datos algebraicos en lenguajes funcionales estaba siendo desarrollada de forma independiente; sin embargo, la relación es evidente. En el citado trabajo de 1981 se exponen a las especies combinatorias como una categoría particular de endofuntores en $\Set$.


\section*{Contribuciones}


En esta tesina se analizan algunas nociones presentadas en los trabajos citados, dejando otras de lado. Particularmente, se trabajará con el universo de containers y sus morfismos, con sus respectivas funciones de extensión y con las construcciones de producto, coproducto, exponencial, objeto inicial y objeto terminal. 

Como contribución original, en el presente trabajo se presenta una formalización en Agda, en términos categóricos, del universo de containers y sus construcciones. Se proveen pruebas formales de que los containers en efecto conforman una categoría y se demuestra que esta cuenta con coproductos, productos, objetos inicial y terminal y exponenciales. En consecuencia, se extienden las librerías de containers existentes a la fecha a la vez que se proveen las garantías de estar construyendo los elementos correctos.

Por otro lado, se provee otra contribución en cuanto a lo que presentación de la temática se refiere. Debido a que este trabajo posee el formato de una tesina de grado y a que no se asumen avanzados conocimientos, la exposición detallada y muchas veces intuitiva resulta un aporte a la comprensión y la difusión del tema expuesto hacia un público más amplio; no solo en lo relativo al caso particular de los containers, sino también a modo de ejemplo de formalización y construcción de un universo para la programación genérica.


\section*{Panorama}

El presente trabajo se encuentra organizado en dos partes.
La primera parte estará avocada a presentar sucintamente nociones básicas de dos lenguajes que utilizaremos a lo largo de toda la tesina. Se trata de, por un lado, el lenguaje de programación {\it Agda}, presentado en el capítulo \ref{chapter:agda} y por otro lado, la teoría de categorías, en el capítulo \ref{cat}. Para el primero seguiremos un camino muchas veces transitado por diversos tutoriales e introducciones a la programación en este lenguaje, por lo que puede obviarse si se poseen conocimientos previos. En el caso del segundo capítulo, por lo contrario, ya se asumirá un manejo del lenguaje Agda y se secundarán todas las definiciones categóricas con formalizaciones dadas en dicho lenguaje. Dichas implementaciones se retomarán en la segunda parte, razón por la cual puede resultar necesaria su lectura para la correcta comprensión de la parte subsiguiente.

La segunda parte nos sumerge ya en el mundo de los containers. En el capítulo \ref{cont} presentaremos formalmente este universo y daremos cuenta de su potencialidad, a partir de analizar de forma intuitiva cada construcción y de proveer múltiples ejemplos. En el capítulo \ref{chapter:construcciones} retomamos la exposición del lenguaje categórico con el objetivo de presentar propiedades sobre containers en estos términos. En contrapunto, veremos la formalización de cada propiedad en Agda y la exposición y prueba de su cumplimiento para el caso particular de la categoría de containers.

Cada capítulo incluye porciones de código Agda en contexto y con la explicación correspondiente. Sin embargo, el código completo puede obtenerse en \gitcode\footnote{ver apéndice \ref{guia}, pág. \pageref{guia}.}.
