%!PS-Adobe-2.0 EPSF-1.2
%%Title: tmpPSFile
%%Creator: dvips(k) 5.996 Copyright 2016 Radical Eye Software
%%CreationDate: Sun Oct 16 02:27:31 2016
%%For:majortommajortom majortom
%%Pages: 1
%%DocumentFonts:
%%BoundingBox: 6 2 413 29
%%HiResBoundingBox: 6.264000 2.178000 412.163987 28.277999
%%EndComments

%%BeginProlog
%%BeginPreview: 407 26 8 286
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000022000000000000000000000000000000000000000000000000
% 22000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000002211000000000000000000000000000000000000000000000000
% eebb0000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000066
% 55000000000000000000000000003300000000000000000000000000000000000000000055883366
% ffff7700000000000000000000000066000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000055883300000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000011000000
% 000000224433225d5d33224422000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000660000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000110000000011000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000004444
% 777700000000000000000000002222000000000000000000000000000000000000000055ffffff3f
% aaffdd000000000000000000000088cc000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 000000000000000000000000000000000055ffffff22000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000022885500000000000000000000000000000000000000000000000000000000000000000000
% 000099ffbb0000
% 000011eeffffffffffffffffff220000000000000000000000000000000000000000000000000000
% 00000000000000000000000088cc0000000000000000000000000000000000000000000000000000
% 000000000000000011eeffffddc0faffffddbbbbbb77000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000330000
% 0000000000000000000000000022000000000000000000000000000000000000000011880022ee33
% 00ddff11000000000000000000007788000000000000000000000000000000000000000000000000
% 000000000000000000000000000000000000000000227799bb886600000000000000000000000000
% 0000000000000000000000000000000011880022ee33000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 000000aaffffbb110000000000000000000000000000000000000000000000000000000000000000
% 006688aaff0000
% 00007766bbaabfccd2aa88aa55000000000000000000000000000000227799bb8866000000000000
% 00000000000000000033110077880000000000000000000000000000444444444444330000000000
% 000000000000000033aabbccffffffffe7ffffffff88000000000000000000000011442200000000
% 00000000442200000000000000000000000000000000000000000000000000000000000000880000
% 00000000000000000000000000220000000000000000000000000000000000000000774400002200
% 0066ff66000000000000000000005588000000000000000000000000000000000000000000000000
% 000000000000000000000000000000000000000088ffaa8888aaffbb000000000000000000000000
% 00000000000000000000000000000000774400002200000000000000000000000000000000000000
% 00000000444444444444330000000000000000000000000000000000000000000000000000000000
% 0000001188ffffcc1100000000000000000000000000000000114422000000000000000044220000
% 00990011ff0000
% 00008800000088000000000000000000000000000000000000000088ffaa8888aaffbb0000000000
% 00000000000000001111000055880000000000000000000000000022ffccbbbbbbbbffdd44000000
% 00000000000000000000000000000088880000008888000000000000000000000000dddd00000000
% 00000099cc1100000000000000000000000000000000000000000000000000000000000022880000
% 00000000000000000000000033000000000000000000000000000000000000000000bb4400000000
% 0011ff88000000000000000000008888000000000000000000000000000000000000000000000000
% 0000000000000000000000000000000000000099cc22000000002266000000000000000000000000
% 00000000000000000000000000000000bb4400000000000000000000000000000000000000000000
% 00000022ffccbbbbbbbbffdd44000000000000000000000000000000000000000000000000000000
% 000000000033eeffee7700000000000000000000000000000000dddd0000000000000099cc110000
% 00aa3300bb0000
% 000099000000990000000000000000000000000000000000000099cc220000000022660000000000
% 00000000000000113300000088880000000000000000000000000055ff11000000001199ee220000
% 00000000000000000000000000000088aa00000088aa00000000000000000000000044ff88000000
% 000099cc110000000000000000000000336688888888888888000000000000000000000044880000
% 00000000000000000000000077000000000000000000000000000000000000000000cc2200000000
% 0000bb88000000000000000000008888000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000044ff1100000000000000000000000000000000000000
% 00000000000000000000000000000000cc2200000000000000000000000000000000000000000000
% 00000055ff11000000001199ee220000000000000000000000000000000000000000000000000000
% 00000000000011aaffffbb11000000000000000000000000000044ff88000000000099cc11000000
% 00000000aa0000
% 0011880000118800000000000000000000000000000000000044ff11000000000000000000000000
% 00000000000000220000000088880000000000000000000000000088dd00000000000000dd880000
% 00000000000000000000000000000088bb00000088bb00000000000000000000000000bbee110000
% 0099dd11000000000000000000000055ffffffffffffffff88000000000000000000000044cc0000
% 00000000000000000000000088000000000000000000000000000000000000000000ff0000000000
% 000088bb000000000000000000008866000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000088bb0000000000000000000000000000000000000000
% 00000000000000000000000000000000ff0000000000000000000000000000000000000000000000
% 00000088dd00000000000000dd880000000000000000000000000000000000000000000000000000
% 000000000000000044ddffee881100000000000000000000000000bbee1100000099dd1100000000
% 00000000660000
% 0044660000446600000000000000000000000000000000000088bb00000000000000000000000000
% 000000000000110000000000886600000000000000000000000000bbaa00000000000000bb880000
% 000000000000000000000000000000448800000044880000000000000000000000000022ff990000
% 99ee3300000000000000000000000033444444444444220000000000000000000000000044bb0000
% 00000000000000000000000088000000000000000000000000000000000000000000ff0000007700
% 00007799000000000000000000008844000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000088ff3300000000000000000000000000000000000000
% 00000000000000000000000000000000ff0000007700000000000000000000000000000000000000
% 000000bbaa00000000000000bb880000000000000000000000000000000000000000000000000000
% 00000000000000000011aaffffdd0000000000000000000000000022ff99000099ee330000000000
% 00000055440000
% 0066440000664400000000000000000000000000000000000088ff33000000000000000000000000
% 000000000022220000000000884400000000000000000000000000ff8800000000000022ff440000
% 00000000000000000000000000000044880000004488000000000000000000000000000088ff2299
% ee330000000000000000000000000000000000000000000000000000000000000000000033880000
% 0000000000000000000000338800000000001188bb33000000000000000000448899ff8888aa1100
% 0000558800000000000000000000882200000000000000000000001188bb33000000000000000000
% 00004444000000000000000000000000000022eeee88440000000000000000000000000000000000
% 00000000000000000000000000448899ff8888aa1100000000000000000000000000000000000000
% 000000ff8800000000000022ff440000000000000000000000000000000000000000000000000000
% 000000000000000000000022bb77000000000000000000000000000088ff2299ee33000000000000
% 000000aaee9922
% 0088440000884400000000000000000000000000000000000022eeee884400000000000000000000
% 0000000000bb881100000000882200000000000000000000000033ff44000000000011ccaa000000
% 00000000000000000000000000000044880000004488000000000000000000000000000011ddeeee
% 33000000000000000000000000000000000000001144668877000000000000000000000044220000
% 000000000000000000000055880000000000994477ee330000000000000066ffffffffffee330000
% 000044880000000000000000000088000000000000000000000000994477ee330000000000000000
% 0033ff7700000000000000000000000000000033bbffffffaa330000000000000000000000000000
% 00000000000000000000000066ffffffffffee330000000000004444000000000000000000000000
% 000033ff44000000000011ccaa0000001188bb330000000000000000000000000000000000000000
% 0000000000000000000000117700000000000000000000000000000011ddeeee3300000000000000
% 00000088ffee00
% 008800000088000000000000000000000000000000000000000033bbffffffaa3300000000000000
% 0000000055ffffdd11000000880000000000000000000000000066ff444444444477dd9911000000
% 0000000000000000000000000000004488000000448800000000000000000000000000000088ff66
% 0000000000000000000000000000004499bbbbffffffffff8800000000000000000044bbaa000000
% 000000000000000000000088550000000033880000000000000000000011bb6688bbdd6622000000
% 0000888800000000000000000000aa00000000000000000000003388000000000000000000000000
% 00aacc110000000000000000000000000000000000115588eeee2200000000000000000000000000
% 000000000000000000000011bb6688bbdd662200000000000033ff77000000000000000000000000
% 000066ff444444444477dd9911000000994477ee3300000000000000000000000000000000000000
% 000000000000000000000066000000000000000000000000000000000088ff660000000000000000
% 00000022882200
% 00990000009900000000000000000000000000000000000000000000115588eeee22000000000000
% 000000000044ccffcc000000aa0000000000000000000000000099ffffffffffcc99440000000000
% 00000000000000000000000000000044880000004488000000000000000000000000000066eeccbb
% 000000000000000000000000000044ffeebbaa887744441100000000000000000000ddffff220000
% 000000000000000000000088440000000088ffdd5500000000000000004444000055bb0000000000
% 0000887700000000000000000000bb000000000000000000000088ffdd5500000000000000000000
% 00552200000000000000000000000000000000000000000033ee8800000000000000000000000000
% 00000000000000000000004444000055bb0000000000000000aacc11000000000000000000000000
% 000099ffffffffffcc99440000000033880000000000000000000000000000000000000000000000
% 0000000000000000000055110000000000000000000000000000000066eeccbb0000000000000000
% 00000088000000
% 0099000000990000000000000000000000000000000000000000000000000033ee88000000000000
% 00000000000011ddffaa0000bb00000000000000000000000000cc99000000000000000000000000
% 00000000000000000000000000000066aa00000066aa0000000000000000000000000066ee3344ff
% 660000000000000000000000000000000000000000000000000000000000000000000077ee880000
% 000000000000000000000088440000000033eeffff88000000000000002299110088990000000000
% 0000884400000000000000000000bb000000000000000000000033eeffff88000000000000000000
% 00000000000000000000000000000000000000000000000000bbbb00000000000000000000000000
% 00000000000000000000002299110088990000000000000000552200000000000000000000000000
% 0000cc99000000000000000000000088ffdd55000000000000000000000000000000000000000000
% 00000000000000000055220000000000000000000000000000000066ee3344ff6600000000000000
% 000000bb330000
% 0088000000880000000000000000000000000000000000000000000000000000bbbb000000000000
% 0000000000000011ddffbb11bb00000000000000000000000000ff77000000000000000000000000
% 00000000000000000000000000000044bb00000044bb00000000000000000000000066ff330000aa
% ee110000000000000000000000000000000000000000000000000000000000000000000088660088
% bb11000000000000000000bb7700000000001188ffee000000000000000000000088880000000000
% 0000882200000000000000000000bb0000000000000000000000001188ffee000000000000000000
% 00000000000000000000000000000000000000000000000000cc8800000000000000000000000000
% 00000000000000000000000000000088880000000000000000000000000000000000000000000000
% 0000ff77000000000000000000000033eeffff880000000000000000000088ffffffccbbbbffffff
% ffee22000000000033220000000000000000000000000000000066ff330000aaee11000000000000
% 000000cc880000
% 3388000033880000000000000000000000000000000000000000000000000000cc88000000000000
% 000000000000000011ddffccc000000000000000000000000044ff44000000000000000000000000
% 00000000000000000000000000000033bb00000033bb000000000000000000000066ff6600000022
% ff880000000000000000000000000000000000000000000000000000000000000000000088440000
% 6644000000000000000000aa880000000099110088bb0000000011ee660000000088880000000000
% 0000aa0000000000000000000000bb110000000000000000000099110088bb000000000000000000
% 0033dd33000000000000000000000000331100000000000055ee2200000000000000000000000011
% ee660000000000000000000000000088880000000000000000000000000000000000000000000000
% 0044ff440000000000000000000000001188ffee0000000000000000000033444444444433000000
% 0000000000000033550000000000000000000000000000000066ff6600000022ff88000000000000
% 00000088770000
% 4488000044880000000000000000000000000000000000331100000000000055ee22000000000000
% 00000000000000000011ccfff121000000000000000000000077ff00000000000000000000000000
% 00000000000000000000000000000000bb00000000bb0000000000000000000055ff660000000000
% 88ff2200000000000000000000000000000000000000000000000000000000000000000099991100
% 991100000000000000000088aa00000066ffdd99aa8800000000bbff6600000000bb880000000000
% 0000880000000000000000000000bb4400000000000000000066ffdd99aa88000000000000000000
% 00dddd0000000000000000000000000099dd660000001177ff5500000000000000000000000000bb
% ff6600000000000000000000000000bb88000000000000000033dd33000000000000000000000000
% 0077ff00000000000000000000000099110088bb0000000000000000000000000000000000000000
% 00000000000011550000000000000000000000000000000055ff66000000000088ff220000000033
% 33000055220000
% 55ddbbbbb0efd6c488886622000000000000000000000099dd660000001177ff5500000000000000
% 0000000000000000000011ccffb40000000000000000000000aabb00000000000000000000000000
% 000000000000000088bbbbbbbbdfe8f1e8bbbbaaccaa00000000000000000033ee66000000000000
% 11eebb00000000000000000000000000000000000000000000000000000000000000000088ffffcc
% 330000000000000000000088ee0000001199ffdd880000000000ffff2200000000bb880000000000
% 000088000000000000000000000077000000000000000000001199ffdd8800000000000000000000
% 11dd33000000000000000000000000002299ffffccccffbb330000000000000000000000000000ff
% ff2200000000000000000000000000bb880000000000000000dddd00000000000000000000000000
% 00aabb000000000000000000000066ffdd99aa880000000000000000000000000000000000000000
% 000000000011770000000000000000000000000000000033ee6600000000000011eebb0000000088
% dd555588000000
% 88ffffffffffffffffffff7700000000000000000000002299ffffccccffbb330000000000000000
% 000000000000000000000011bf220000000000000000000000dd8800000000000000000000000000
% 00000000000000118888888890d0b8c8a08899668833000000000000000033ee6600000000000000
% 0077ff55000000000000000000000000000000000000000000000000000000000000000022bbdd66
% 000000000000000000000077ff1100000000000000000000000033bb0000000000bb550000000000
% 00225500000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000444444220000000000000000000000000000000033
% bb0000000000000000000000000000bb550000000000000011dd3300000000000000000000000000
% 00dd8800000000000000000000001199ffdd88000000000000000000000000000000000000000000
% 0000000011770000000000000000000000000000000033ee66000000000000000077ff5500000011
% 88aa8811000000
% 223333445d6969444444440000000000000000000000000000004444442200000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 000000000000000000000044ff8800000000000000000000000022660000000000bb110000000000
% 00551100000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000022
% 660000000000000000000000000000bb110000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000331100000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 000000000000000000000011ffff4400000000000000000000008800000000000099000000000000
% 00440000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000088
% 00000000000000000000000000000099000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 000000000000000000000000bbffcc44000000000000000033993300000000002244000000000000
% 00440000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000339933
% 00000000000000000000000000002244000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000033ffffdd000000000000000099330000005555338800000000000000
% 55110000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000993300
% 00000000000000000000005555338800000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 0000000000000000000000000088ff9900000000000000000000000022ffffee3300000000000000
% 77000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 0000000000000000000022ffffee3300000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000118822000000000000000000000000004455220000000000000022
% 33000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000004455220000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000000000000000000000000000000000000000000000000000000000000000000000
% 00000000000000
%%EndImage
%%EndPreview
save countdictstack mark newpath /showpage {} def /setpagedevice /pop load def
%%EndProlog
%%Page 1 1
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: dvips -Pdownload35 -T
%+ 17.120000002980234cm,8.320000002980231cm tmpPSFile -o
%+ /tmp/latexdraw/latexdrawTmp147659565091448108/tmpPSFile.ps
%DVIPSParameters: dpi=600
%DVIPSSource:  TeX output 2016.10.16:0227
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/dir 0 def/dyy{/dir 0 def}B/dyt{/dir 1 def}B/dty{/dir 2 def}B/dtt{/dir 3
def}B/p{dir 2 eq{-90 rotate show 90 rotate}{dir 3 eq{-90 rotate show 90
rotate}{show}ifelse}ifelse}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0
N/Ry 0 N/V{}B/RV/v{/Ry X/Rx X V}B statusdict begin/product where{pop
false[(Display)(NeXT)(LaserWriter 16/600)]{A length product length le{A
length product exch 0 exch getinterval eq{pop true exit}if}{pop}ifelse}
forall}{false}ifelse end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{
BDot}imagemask grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat
{BDot}imagemask grestore}}ifelse B/QV{gsave newpath transform round exch
round exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0
rlineto fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B
/M{S p delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}
B/g{0 M}B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p
-3 w}B/n{p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{
0 S rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

% $Id: pstricks.pro 919 2014-05-19 18:42:47Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 1.24, 2016/04/22
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
% Define the follwing gs-functions if not known, eg when using distiller
%
systemdict /.setopacityalpha known not {/.setopacityalpha { pop } def } if
systemdict /.setblendmode known not {/.setblendmode { pop } def } if
systemdict /.setshapealpha known not {/.setshapealpha { pop } def } if
%
/tx@Dict 200 dict def 				% the main PSTricks dictionary
tx@Dict begin
/ADict 25 dict def				% The arrow dictionary
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known
/ATAN1 {neg -1 atan 180 sub } def		% atan(x) (only one parameter)
/Div { dup 0 eq { pop } { div } ifelse } def  	% control the division
/Log { dup 1e-20 lt { pop -1e30 }{ log } ifelse } def % control the log
/tan { dup cos abs 1.e-10 lt 
  { pop 1.e10 } 				% return 1.e10 as infinit
  { dup sin exch cos div } ifelse 		% default sin/cos
} def
/Tan { dup sin exch cos Div } def 		% sin(x)/cos(x) x in degrees
/Acos {dup dup mul neg 1 add dup 0 lt {		% arc cos, returns 0 when negative root
  pop pop 0 }{ sqrt exch atan} ifelse } def
/Acos2 { 2 dict begin 
  /x ED /y ED
  y abs 1.0e-20 lt { 1.0e30 } if
  x y div 
  dup dup mul neg 1 add dup 0 lt {		% arc cos needs two values x,y
  pop pop 0 }{ sqrt exch atan} ifelse 
  y 0 lt { 180 add } if
} def
/NET { neg exch neg exch T } def	      	% change coordinate system to the negative one		
/Pyth { dup mul exch dup mul add sqrt } def   	% Pythagoras, expects 2 parameter
/Pyth2 {					% Pythagoras, xA yA xB yB
  3 -1 roll 		% xA xB yB yA
  sub			% xA xB yB-yA
  3 1 roll 		% yB-yA xA xB
  sub			% yB-yA xA-xB
  Pyth } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def % Polar to Cartesian
/PtoCab { dup cos 4 -1 roll mul 3 1 roll sin mul } def % Polar to Cartesian (Ellipse) a b phi-> x y 
%/Rand { rand 4294967295 div } def		% a real random number
/Rand { rand 2147483447 div } def		% a real random number between 0 and 1
%----------------- hv added 20050516 ---------------
/PiDiv2 1.57079632680 def
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def
/Euler 2.71828182846 def 
%/e Euler bind def
%
/RadtoDeg { 180 mul Pi div } bind def 		% convert from radian to degrees
/DegtoRad { Pi mul 180 div } bind def 		% viceversa
%
/startGlobal { true setglobal globaldict begin } bind def
/endGlobal { end false setglobal } bind def
/pssetRGBcolor /setrgbcolor load def
/pssetCMYKcolor /setcmykcolor load def
/pssetGraycolor /setgray load def
%
%----------------- hv end---------------------------
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def
%
/PathLength { 
  flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def }
  { /y ED /x ED PathLength@ } 
  {} 
  { /y y2 def /x x2 def PathLength@ }
  /pathforall load stopped { pop pop pop pop } if 
  z 
} def
%
/STP { .996264 dup scale } def			% BP/PT scaling
/STV { SDict begin normalscale end STP  } def	% 
%
/DashLine {
    dup 0 gt
    { /a .5 def PathLength exch div }
    { pop /a 1 def PathLength } ifelse
    /b ED % pattern should fit evenly in b
    dup /X ED % pattern array
    0 get /y ED % length of first black segment
    /z 0 X {add} forall def % length of the full pattern
    %% Computation of the scaling factor as described by van Zandt:
    b a .5 sub 2 mul y mul sub z Div round
    z mul a .5 sub 2 mul y mul add b exch Div
    %%%% scaling factor on stack.
    /z ED %% now, z is the scaling factor
    false % for the length test below
    X { z mul } forall X astore %% modification TN 04-08-07
    %%% Checking whether at least one dash in X has positive length:
    {0 gt or} forall
    { X 1 a sub y mul }
    { [ 1 0 ] 0 }
    ifelse
    setdash stroke
} def
%
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def
%
/SymbolLine {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 div cvi /n ED     				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    %% for negative SymStep we calculate the distance 
    SymStep 0 lt 
      { %XYLength SymStep div abs cvi 
        /nSym SymStep abs cvi def } 
      { /nSym XYLength SymStep div cvi def }
    ifelse
    0.5 setflat
    /Shift Symbol stringwidth pop 2 div def 
    /deltaX XLength nSym div def
    /deltaY YLength nSym div def
    curveticks 
      { XA YA moveto }
      { XA Shift sub YA Shift sub moveto }
    ifelse 
    nSym { 
      gsave 
      curveticks 
        { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
          currentpoint translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
          Symbol show 
        }
      ifelse 
      grestore 
      deltaX deltaY rmoveto
    } repeat
    /YA YB def /XA XB def
  } repeat 
  curveticks 
    { XA YA moveto }
    { XA Shift sub YA Shift sub moveto }
  ifelse 
  gsave 
  curveticks 
    { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
      XA YA translate rotAngle rotate 
      0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
      SymbolLinewidth setlinewidth stroke
    }
    { 
      rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
    }
  ifelse 
  grestore
  pop 				% delete the mark symbol
} def
%
/LineFill { % hv ------------ patch 7 -------------
  gsave 
  abs /hatchWidthInc ED
  abs /hatchSepInc ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  2 setlinecap 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def
      CLW hatchWidthInc add SLW 
    } if
  } repeat 
  grestore 
  pop pop } def
%
/DotFill {%	 on stack: dot radius
  /dotRadius ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform 
  pathbbox % llx lly urx ury of smallest bounding box
  /y2 ED /x2 ED /y1 ED /x1 ED 
  y2 y1 sub a div 2 add cvi /Ny ED
  x2 x1 sub a div 2 add cvi /Nx ED
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  /yA y1 dotRadius add CLW add def
  /xA0 x1 dotRadius add CLW add def
  Ny {
     /xA xA0 def
     Nx { 
       newpath 
       xA yA dotRadius 0 360 arc 
       SolidDot { gsave fill grestore } if 
       stroke
       xA a add /xA ED
     } repeat
     yA a add /yA ED
  } repeat
  grestore
} def
%
/PenroseFill {%	 on stack: scaling factor
  /Scale ED
%  1 exch div round /penroseFactor ED 
%  a 0 dtransform round exch round exch
%  2 copy idtransform 
%  exch Atan rotate 
%  idtransform pop /a ED 
%  .25 .25 itransform pathbbox 
%  /y2 ED 
%  a Div ceiling cvi /x2 ED /y1 ED 
%  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
gsave
  220 150 translate
  Scale dup scale
  systemdict /setstrokeadjust known { true setstrokeadjust } if 
  /I/S/L/W/G/+/Z/F/E/D[/def/exch/for{E D}/add{s E get mul}
 { Z -36.2001 1 33 }{25 E S rlineto}{/q Z dup q G E q 1 + G}{Z 2 2}]{cvx def}forall
  [0 72 1008 {dup sin E cos }F ]1 setlinejoin/s W{/a W{/b I 10{/i I 4{/m I moveto
  i m +/j I 10{/l Z b m l + G a l G sub s m get div .2 + floor .3 + 25
  mul j l + S rmoveto}F i L j L stroke }F}F}F}F 
  grestore 
%  pop pop 
} def
%
/PenroseFillA {%  on stack: scaling factor, border color, kite color, dart color
  /Scale ED
  Scale dup scale
  /border_colour ED 
  /kite_colour ED 
  /dart_colour ED
  clip 
  newpath 
  gsave
  100 100 translate
  6 
  Scale 1 lt { 1 Scale dup add div mul cvi } if %%%%   Number of iterations
  10					%%%%   Long side length in millimeters
  /border_width { L 0.06 mul }def		%%%%   Choose the scalefactor for the borders
  /L exch 25.4 div 72 mul def		%%%%   Conversion: mm -> inches -> points
  /f{-1 5 sqrt add 2 div}bind def		%%%%   The reciprocal of the golden ratio
  /l{L f mul}bind def			%%%%   Short side length l = L*f
  /Ll{L l add}bind def			%%%%   Ll =  L + l
  /c{36 cos L mul}bind def		%%%%   c  =  L*cos(36)
  /s{36 sin L mul}bind def		%%%%   s  =  L*sin(36)
  /draw_tile { 0 0 moveto c s lineto 0 lineto gsave closepath gsave fill grestore
	     0 setlinewidth stroke grestore border_colour stroke } bind def
  /half_kite { dup dup 0 gt{ 1 sub gsave f f neg scale -36 rotate half_dart
			   Ll 0 translate 144 rotate kite grestore }
	      		 { kite_colour L draw_tile }ifelse
	     pop } bind def
  /half_dart { dup dup 0 gt{ 1 sub gsave f f scale half_kite
			   -144 rotate Ll neg 0 translate half_dart grestore }
	      		 { dart_colour l draw_tile }ifelse
  	     pop } bind def
  /kite{ gsave half_kite 1 -1 scale half_kite grestore }bind def
  border_width setlinewidth  1 setlinejoin  1 setlinecap
%  450 0 translate  
  dup f exch neg exp dup scale
  5 {kite 72 rotate } repeat stroke 
  grestore
} def
%
%
/TruchetFill { %	 on stack: scaling factor
  10 dict begin
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /ma a neg def
  /ha a 2 div def 
  /mha ha neg def
  /tile { 
    rand dup 2 idiv 2 mul eq { 90 rotate } if
    mha mha moveto ha mha lineto
    ha ha lineto mha ha lineto
%    closepath .1 setlinewidth stroke
    contents
  } def
  /contents{ 
    0 ha moveto ha 0 lineto
    0 mha moveto mha 0 lineto
%    1 setlinewidth stroke
  } def
  /dotiling {
    f ma mul a f a mul { 
      /i exch def
      f ma mul a f a mul { 
        /j exch def
        gsave i j translate
        tile stroke grestore
      } for
    } for
  } def
%
  /f 3 def 
  5 srand dotiling 
  end % local user dict
} def
%
/BeginArrow { 
  ADict begin 			% hold it local, for end see EndArrow
  /@mtrx CM def 
  gsave 
  2 copy T 
  2 index sub neg exch 
  3 index sub exch Atan 
  rotate newpath 
} def
%
/EndArrow { @mtrx setmatrix CP grestore end } def % end the ADict
%
/Arrow { 
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /a ED 
  { 0 h T 1 -1 scale } if 
  w neg h moveto 
  0 0 L w h L w neg a neg rlineto 
  gsave fill grestore 
} def
%
/ArrowD { % the sides are drawn as curves (hv 20071211)
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /Inset ED 
  { 0 h T 1 -1 scale } if % changes the direction
% we use y=w/h^2 * x^2 as equation for the control points
% for the coordinates the arrow is seen from top to bottom
% the bottom (tip) is (0;0)
  w neg h moveto % lower left of >
  w 9 div 4 mul neg h 3 div 2 mul
  w 9 div neg       h 3 div  
  0 0 curveto    % tip of >
  w 9 div        h 3 div  
  w 9 div 4 mul  h 3 div 2 mul
  w h curveto % upper left of >
  w neg Inset neg rlineto % move to x=0 and inset
  gsave fill grestore 
} def 
%
/Tbar { 
  CLW mul add /z ED 
  z -2 div CLW 2 div moveto 
  z 0 rlineto stroke 
  0 CLW moveto 
} def
%
/Bracket { 
  CLW mul add dup CLW sub 2 div 
  /x ED mul CLW add /y ED /z CLW 2 div def 
  x neg y moveto 
  x neg CLW 2 div L x CLW 2 div L x y L stroke 
  0 CLW moveto 
} def
%
/RoundBracket { 
  CLW mul add dup 2 div 
  /x ED mul /y ED /mtrx CM def 
  0 CLW 2 div T x y mul 0 ne { x y scale } if 
  1 1 moveto 
  .85 .5 .35 0 0 0 curveto 
  -.35 0 -.85 .5 -1 1 curveto 
  mtrx setmatrix stroke 0 CLW moveto 
} def
%
/SD { 0 360 arc fill } def
%
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse  	% outer or inner dimen 
  /b ED 				% the color definition
  0 z DS SD 
  b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub 
  moveto 
} def
%
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
  load } if ] cvx newpath 3 1 roll T exec } def
%
/NArray { % holds the coordinates and on top of stack the showpoints boolean
  /showpoints ED 
  counttomark 2 div dup cvi /n ED  	% n 2 div on stack 
  n eq not { exch pop } if		% even numbers of points? delete one
  ] aload /Points ED 
  showpoints not { Points aload pop } if
%    { ] aload /Points ED } 
%    { n 2 mul 1 add -1 roll pop } ifelse	% delete the mark symbol 
} def
%
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def
%
/LineToYAxis {
  /Ox ED		% Save the x origin value 
  NArray            % all x-y pairs on stack
  n { 2 copy moveto % go to current point
    Ox exch Lineto   % line to y-axis
    pop             % delete old x-value
  } repeat
} def
%
/LineToXAxis{
  /Oy ED		% Save the y origin value 
  NArray		% all x-y pairs on stack
  n 0 eq not
    { n 1 eq { 0 0 /n 2 def } if
      ArrowA
      /n n 2 sub def
      CP 2 copy moveto pop Oy Lineto
      n { 2 copy moveto pop Oy Lineto } repeat
      CP
      4 2 roll
      ArrowB
      2 copy moveto pop Oy
      L
      pop pop } if
} def
%
/Arcto { 
  /a [ 6 -2 roll ] cvx def 
  a r 
  /arcto load stopped { 5 } { 4 } ifelse { pop } repeat 
  a 
} def
%
/CheckClosed { 
  dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
  and { pop pop /n n 1 sub def } if 
} def
%
/Polygon { 
  NArray n 2 eq { 0 0 /n 3 def } if 
  n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      n 2 mul -2 roll 
      /y0 ED /x0 ED /y1 ED /x1 ED  
      x1 y1 
      /x1 x0 x1 add 2 div def 
      /y1 y0 y1 add 2 div def 
      x1 y1 moveto 
      /n n 2 sub def 
      n { Lineto } repeat 
      x1 y1 x0 y0 6 4 roll Lineto
      Lineto pop pop closepath } ifelse 
} def
%
/SymbolPolygon {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 add /m ED
  2 copy m 2 roll				% copy last two
  m 2 div cvi /n ED    				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    /nSym XYLength SymStep Div cvi def
    /Shift Symbol stringwidth pop 2 Div def 
    /deltaX XLength nSym Div def
    /deltaY YLength nSym Div def
    XA Shift sub YA Shift sub moveto 
    nSym { 
      gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
      grestore 
      deltaX deltaY rmoveto
    } repeat
%    XB Shift sub YB Shift sub moveto Symbol show
    /YA YB def /XA XB def
  } repeat 
  pop	% delete the mark symbol
} def
%
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def
%
/Triangle { 
  /mtrx CM def 
  translate 
  rotate /h ED 2 div /w ED 
  dup CLW mul /d ED 
  /h h d w h Atan sin Div sub def 
  /w w d h w Atan 2 div dup cos exch sin Div mul sub def 
  mark 
  0 d w neg d 0 h w d 0 d 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false 
  Line 
  closepath 
  mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
  setmatrix pop 
} def
% DG/SR modification end
%
/CCA { 
  /y ED /x ED 
  2 copy y sub /dy1 ED 
  x sub /dx1 ED 
  /l1 dx1 dy1 Pyth def 
} def
%
/CC { 
  /l0 l1 def 
  /x1 x dx sub def 
  /y1 y dy sub def 
  /dx0 dx1 def 
  /dy0 dy1 def 
  CCA 
  /dx dx0 l1 c exp mul dx1 l0 c exp mul add def 
  /dy dy0 l1 c exp mul dy1 l0 c exp mul add def 
  /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos abs b exp a mul dx dy Pyth Div 2 div def 
  /x2 x l0 dx mul m mul sub def
  /y2 y l0 dy mul m mul sub def 
  /dx l1 dx mul m mul neg def 
  /dy l1 dy mul m mul neg def 
} def
%
/IC { 
  /c c 1 add def 
  c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if } ifelse 
  /a a 2 mul 3 div 45 cos b exp div def 
  CCA 
  /dx 0 def 
  /dy 0 def 
} def
%
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
%
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def
%
/CurvePath { 
  %% for negative SymStep we calculate the distance 
  SymStep 0 lt { gsave PathLength SymStep div abs /SymStep ED grestore } if
  0.5 setflat
  flattenpath /z 0 def /z0 0 def
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def 
    x1 Shift sub y1 Shift sub moveto 
    gsave 
    curveticks 
      { x1 y1 translate startAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke      
      }
      { startAngle rotate Symbol show }
    ifelse 
    grestore /z0 z def }
  { /y ED /x ED PathLength@ z z0 sub SymStep ge {
      x Shift sub y Shift sub moveto 
      gsave 
      curveticks 
        { y yOld sub x xOld sub Atan 180 sub CorrAngle sub /rotAngle ED  
          x y translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
          Symbol show 
        }
      ifelse 
      grestore /z0 z def } if 
    /yOld y def /xOld x def } 
  {} %% the lineto part
  { /y y2 def /x x2 def PathLength@ 
    x Shift sub y Shift sub moveto 
    gsave
    curveticks 
      { y yOld sub x xOld sub Atan 180 sub /rotAngle ED  
        x y translate rotAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke
      }
      { 
        x Shift sub y Shift sub moveto 
        rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
        Symbol show 
      }
    ifelse 
    grestore
  }
  pathforall 
%  curveticks 
%   { gsave 
%     x y translate rotAngle rotate 
%     0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
%     SymbolLinewidth setlinewidth stroke grestore
%   } if
  z 
} def
%
/OpenSymbolCurve { 
  OpenCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/AltCurve { 
  { false NArray n 2 mul 2 roll 
    [ n 2 mul 3 sub 1 roll ] aload
    /Points ED 
    n 2 mul -2 roll } 
  { false NArray } ifelse 
  n 4 lt { n { pop pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse 
} def
%
/AltOpenSymbolCurve { 
  AltCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      6 copy n 2 mul 6 add 6 roll 
      IC CC x y moveto n { NC } repeat 
      closepath pop pop 
    } ifelse 
} def
%
/ClosedSymbolCurve { 
  ClosedCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/CalcBezierSpline {%  Christoph Bersch
  10 dict begin
  /getX { Points exch 2 mul get } def
  /getY { Points exch 2 mul 1 add get } def
  /n Points length 1 sub 2 idiv def
  /GetFirstControlPoints {
    /x n array def
    /tmp n array def
    /b 2 def
    x 0 rhs 0 get b div put
    1 1 n 1 sub {
      /i exch def
      tmp i 1 b div dup 4 1 roll put
      i n 1 sub lt { 4 }{ 3.5 } ifelse exch sub /b exch def
      x i rhs i get x i 1 sub get sub b div put
    } for
    1 1 n 1 sub {
      n exch sub
      dup dup x exch 1 sub 2 copy 6 2 roll
      get 3 1 roll tmp exch get
      exch x exch get mul sub
      put	
    } for
    x
  } def
  % 
  n 1 eq {
    0 getX 2 mul 1 getX add 3 div
    0 getY 2 mul 1 getY add 3 div
    exch dup 3 1 roll 2 mul 0 getX sub
    exch dup 3 1 roll 2 mul 0 getY sub
    [ 0 getX 0 getY 7 3 roll 1 getX 1 getY ] /outPoints exch def
  } {
    /outPoints 6 n mul 2 add array def
    0 1 n {
      dup dup 6 mul dup 1 add
      outPoints exch 5 -1 roll getY put
      outPoints exch 3 -1 roll getX put
    } for
    /rhs n array def
    1 1 n 2 sub {
      rhs exch dup dup getX 4 mul exch 1 add getX 2 mul add put
    } for
    rhs 0 0 getX 1 getX 2 mul add put
    rhs n 1 sub dup getX 8 mul n getX add 2 div put
    GetFirstControlPoints
    1 1 n 2 sub {
      rhs exch dup dup getY 4 mul exch 1 add getY 2 mul add put
    } for
    rhs 0 0 getY 1 getY 2 mul add put
    rhs n 1 sub dup getY 8 mul n getY add 2 div put
    GetFirstControlPoints
    0 1 n 1 sub {
      /i exch def
      2 copy
      i get outPoints 6 i mul 3 add 3 -1 roll put
      i get outPoints 6 i mul 2 add 3 -1 roll put
      2 copy
      i n 1 sub lt {
        i 1 add get i 1 add getY 2 mul exch sub outPoints 6 i mul 5 add 3 -1 roll put
        i 1 add get i 1 add getX 2 mul exch sub outPoints 6 i mul 4 add 3 -1 roll put
      }{
        n 1 sub get n getY add 2 div outPoints 6 n 1 sub mul 5 add 3 -1 roll put
        n 1 sub get n getX add 2 div outPoints 6 n 1 sub mul 4 add 3 -1 roll put
      } ifelse
    } for
    pop pop
  } ifelse
  outPoints
  end
} def
/Spline {
  /showpoints ED
  counttomark 2 div dup cvi /n ED
  n eq not { exch pop } if
  ] /Points ED
  n 1 gt {
    CalcBezierSpline
    mark exch aload pop
    ArrowA
    n 2 sub {
      6 2 roll 4 2 roll curveto
    } repeat
    6 2 roll 4 2 roll ArrowB curveto
  } if
} def
/OpenSymbolSpline {
  Spline
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore } def
%
/FontDot { 
  DS 2 mul dup 
  matrix scale matrix concatmatrix exch matrix
  rotate matrix concatmatrix exch 
  findfont exch makefont setfont 
} def
%
/Rect { 
  x1 y1 y2 add 2 div moveto 
  x1 y2 lineto 
  x2 y2 lineto 
  x2 y1 lineto
  x1 y1 lineto 
  closepath 
} def
%
/OvalFrame { 
  x1 x2 eq y1 y2 eq or 
    { pop pop x1 y1 moveto x2 y2 L } 
    { y1 y2 sub abs x1 x2 sub abs 2 copy gt 
      { exch pop } { pop } ifelse 
      2 div exch { dup 3 1 roll mul exch } if 
      2 copy lt { pop } { exch pop } ifelse
      /b ED 
      x1 y1 y2 add 2 div moveto 
      x1 y2 x2 y2 b arcto 
      x2 y2 x2 y1 b arcto
      x2 y1 x1 y1 b arcto 
      x1 y1 x1 y2 b arcto 
      16 { pop } repeat 
      closepath 
    } ifelse 
} def
%
/Frame { 
  CLW mul /a ED 
  3 -1 roll 
  2 copy gt { exch } if 
  a sub /y2 ED 
  a add /y1 ED 
  2 copy gt { exch } if 
  a sub /x2 ED 
  a add /x1 ED 
  1 index 0 eq { pop pop Rect } { OvalFrame } ifelse 
} def
%
/BezierNArray { 
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if 
  n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat 
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/OpenBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { ArrowA n 4 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      6 2 roll 4 2 roll ArrowB curveto } ifelse 
} def
%
/OpenSymbolBezier { 
  OpenBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { moveto n 1 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      closepath } ifelse 
} def
%
/ClosedSymbolBezier { 
  /f ED				 % save showpoints value 
  2 copy /yEnd ED /xEnd ED
  counttomark -2 roll 2 copy /yStart ED /xStart ED
  counttomark 2 roll
  f
  ClosedBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
  [ xEnd yEnd xStart yStart SymbolLine 
} def
%
/BezierShowPoints { 
  gsave 
  Points aload length 2 div cvi /n ED 
  moveto 
  n 1 sub { lineto } repeat 
  CLW 2 div SLW [ 4 4 ] 0 setdash stroke 
  grestore 
} def
%
/Parab { 
  /y0 ED /x0 ED /y1 ED /x1 ED 
  /dx x0 x1 sub 3 div def 
  /dy y0 y1 sub 3 div def 
  x0 dx sub y0 dy add x1 y1 ArrowA
  x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 x0 y0 x0 2 mul x1 sub y1 ] def 
} def
%
/Parab1 { % 1 end  |  0 SP
  /ySP ED /xSP ED /y1 ED /x1 ED 
  /dx xSP x1 sub 3 div def 
  /dy ySP y1 sub 3 div def 
  newpath x1 y1 moveto xSP y1 lineto xSP ySP lineto 
                       x1 ySP lineto closepath clip 
  currentpoint
  newpath moveto
  xSP dx sub ySP dy add x1 y1 ArrowA
  xSP dx add ySP dy add xSP 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 xSP ySP xSP 2 mul x1 sub y1 ] def 
} def
%
/Grid { 
  newpath 
  /a 4 string def 
  /b ED % 				psk@gridlabels in pt
  /c ED % 				{ \pst@usecolor\psgridlabelcolor }
  /n ED % 				psk@griddots
  cvi dup 1 lt { pop 1 } if 
  /s ED % 				\psk@subgriddiv
  s div dup 0 eq { pop 1 } if 
  /dy ED s div dup 0 eq { pop 1 } if %	\pst@number\psyunit abs
  /dx ED dy div round dy mul %		\pst@number\psxunit abs
  /y0 ED dx div round dx mul 
  /x0 ED dy div round cvi 
  /y2 ED dx div round cvi 
  /x2 ED dy div round cvi 
  /y1 ED dx div round cvi 
  /x1 ED 
  /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def 
  /w x2 x1 sub 0 gt { 1 } { -1 } ifelse def 
  b 0 gt { 
    /z1 b 4 div CLW 2 div add def
%    /Helvetica findfont b scalefont setfont 
    /b b .95 mul CLW 2 div add def } if 
  systemdict /setstrokeadjust known 
    { true setstrokeadjust /t { } def }
    { /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
       exch itransform } bind def } ifelse 
  gsave n 0 gt { 1 setlinecap [ 0 dy n div ] dy n div 2 div setdash } { 2 setlinecap } ifelse 
  /i x1 def 
  /f y1 dy mul n 0 gt { dy n div 2 div h mul sub } if def 
  /g y2 dy mul n 0 gt { dy n div 2 div h mul add } if def 
  x2 x1 sub w mul 1 add dup 1000 gt { pop 1000 } if 
  { i dx mul dup y0 moveto 
    b 0 gt 
      { gsave c i a cvs dup stringwidth pop 
        /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse 
	h 0 gt {b neg}{z1} ifelse 
        rmoveto show grestore } if 
    dup t f moveto 
    g t L stroke 
    /i i w add def 
  } repeat 
  grestore 
  gsave 
  n 0 gt
  % DG/SR modification begin - Nov. 7, 1997 - Patch 1
  %{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
    { 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
  % DG/SR modification end
    { 2 setlinecap } ifelse 
  /i y1 def 
  /f x1 dx mul n 0 gt { dx n div 2 div w mul sub } if def 
  /g x2 dx mul n 0 gt { dx n div 2 div w mul add } if def 
  y2 y1 sub h mul 1 add dup 1000 gt { pop 1000 } if 
  { newpath i dy mul dup x0 exch moveto 
    b 0 gt { gsave c i a cvs dup stringwidth pop 
      /z2 ED 
      w 0 gt {z1 z2 add neg} {z1} ifelse 
      h 0 gt {z1} {b neg} ifelse 
      rmoveto show grestore } if 
    dup f exch t moveto 
    g exch t L stroke 
    /i i h add def 
  } repeat 
  grestore 
} def
%
/ArcArrow { 
  /d ED /b ED /a ED 
  gsave 
  newpath 0 -1000 moveto clip 
  newpath 
  0 1 0 0 b 
  grestore 
  c mul 
  /e ED 
  pop pop pop r a e d PtoC y add exch x add
  exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
  mul neg d 
} def
%
%
/isbool { type (booleantype) cvn eq } def
%
/Ellipse { 
  dup isbool { /MoveToStart ED }{ /MoveToStart false def }ifelse  % false or true
  /rotAngle ED
  /mtrx CM def 
  T 
  rotAngle rotate
  scale 
  MoveToStart { 0 0 moveto 1 0 rmoveto } if  % move to the start position
  0 0 1 5 3 roll arc 
  mtrx setmatrix 
} def
%
/ArcAdjust { %%%% Vincent Guirardel
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, %
% the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub
% maximum number of times to iterate the iterative procedure:
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack)
  30 { dup
% compute distance D between (x0,y0) and M(t)
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
    dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
    2 index Div targetLength mul y0 add ry Div exch
    2 index Div targetLength mul x0 add rx Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
    atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
%
% begin bug fix 2006-01-11
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180
%(we don't want to make the ellipse turn more or less than it should)...
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse
% end bug fix
} def
%
/EllipticArcArrow {
  /d ED      % is add or sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul xOrig add % hv 2007-08-29   x->xOrig
  a2 sin ry mul yOrig add % hv 2007-08-29   y->yOrig
  a1 cos rx mul xOrig add % 
  a1 sin ry mul yOrig add % 
% Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap.
} def
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
%
/RotBegin { 
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
  /a ED 
  a Rot /RAngle [ RAngle dup a add ] cvx def 
} def
%
/RotEnd { 
  /TMatrix [ TMatrix setmatrix ] cvx def 
  /RAngle [ RAngle pop ] cvx def 
} def
%
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/Uput {
  /a ED 
  add 2 div /h ED 2 
  div /w ED 
  /s a sin def 
  /c a cos def 
  /b s abs c abs 2 copy gt dup 
    /q ED 
    { pop } { exch pop } ifelse def 
  /w1 c b div w mul def 
  /h1 s b div h mul def 
  q { w1 abs w sub dup c mul abs }{ h1 abs h sub dup s mul abs } ifelse 
} def
%
/UUput { 
  5 dict begin
  /z ED 
  abs /y ED 
  /x ED 
  q { x s div c mul abs y gt }{ x c div s mul abs y gt } ifelse 
    { x x mul y y mul sub z z mul add sqrt z add } 
    { q { x s div } { x c div } ifelse abs 
    } ifelse 
  a PtoC 
  h1 add exch 
  w1 add exch 
  end
} def
%
end
%-----------------------------------------------------------------------------%
%
% END pstricks.pro

% $Id: pst-algparser.pro 919 2014-05-19 18:42:47Z herbert $
%%
%% PostScript prologue for PSTricks algorithm parser
%% Version 0.07, 2014/08/01
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%%-----------------------------------------------------------------------------%
%
%currentdict /Pi known not { /Pi 3.14159265359 def } if
%
/AlgParser { tx@AlgToPs begin AlgToPs end } def  % Dominique Rodriguez
/I2P { AlgParser cvx exec } def  % Infix to Postfix
%
/tx@CoreAnalyzerDict 100 dict def tx@CoreAnalyzerDict begin
%
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.13
%
% 09/2011 DR factorial with ! added
%
% E->T|E+T
% T->FS|T*FS
% FS -> F | +FS | -FS
% F->P|F^SF|P!
% P->(E)|literal
% literal->number|var|var[E]|func(params)
% params->E|E,param
% number->TOBEFINISHED
%
%% E expression, T term, SF signed factor, F factor, P power
%
%% parser
%
%% str
%
%% C->E<condition_operators>E
%% STR index -> STR index+lenExpr
/AnalyzeCond { AnalyzeExpr ReadCondOp AnalyzeExpr EvalCondOp  } def
%
%% analyze Expression List (separator , or | )
%% STR index -> STR index+lenExpr
%% /AnalyzeListOfE {
%%   { NextNonBlankChar pop AnalyzeExpr%%dup Strlen eq { exit } if NextNonBlankChar
%%     NextNonBlankChar dup 0 eq { pop exit } if
%%     dup 44 ne 1 index 124 ne and { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } if
%%     pop NextNonBlankChar dup 0 eq { exit } if 124 ne { PROBLEMCONTACTBILLOU } if 1 add NextNonBlankChar 0 eq {toto} if } loop
%%   AnalyzeListOfEPostHook
%% } def
/AnalyzeListOfE {
  /NotFirst false def
  { NextNonBlankChar pop AnalyzeExpr
    NotFirst { EvalListOfExpr } { /NotFirst true def } ifelse
    dup Strlen eq { exit } if NextNonBlankChar
    dup 44 ne 1 index 124 ne and
    { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse }
    if  pop 1 add } loop
  AnalyzeListOfEPostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% E->T|E+T
%% STR index -> STR index+lenExpr
/AnalyzeExpr {
  AnalyzePreHook AnalyzeTerm IsEndingExpr
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeTerm PreEvalHook EvalAddSub IsEndingExpr { pop exit } if } loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% T->FS|T*FS
%% STR index
/AnalyzeTerm {
  AnalyzePreHook AnalyzeSignedFactor IsEndingTerm
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor PreEvalHook EvalMulDiv IsEndingTerm { pop exit } if} loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FS -> F | +FS | -FS
%% STR index
/AnalyzeSignedFactor {
  AnalyzePreHook 2 copy get dup IsUnaryOp
  { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor EvalUnaryOp }
  { pop AnalyzeFactor }
  ifelse AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% F->P|F^P|P!
%% STR index
/AnalyzeFactor {
  AnalyzePreHook AnalyzePower IsEndingFactor
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { dup 33 eq%% is there a ! DR 09/2011
      { pop 1 add NextNonBlankChar pop EvalFactorial }
      { RollOp 1 add NextNonBlankChar pop AnalyzePower PreEvalHook EvalPower }
      ifelse
      IsEndingFactor { pop exit } if } loop }
  ifelse  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% P->(E)|literal
%% STR index
/AnalyzePower {
  %% depending of first char either a number, or a literal
  2 copy get dup 40 eq%%an open par
  { pop 1 add NextNonBlankChar pop AnalyzeExpr 1 add NextNonBlankChar pop }
  { AnalyzeLiteral }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index STR[index] -> STR index
%/AnalyzeLiteral { IsNumber { EvalNumber } { EvalLiteral } ifelse } def
/AnalyzeLiteral { dup IsUnaryOp exch IsNumber or { EvalNumber } { EvalLiteral } ifelse } def%%dr 09102006
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% recognize + or -
%% chr -> T/F
/IsUnaryOp { dup 43 eq exch 45 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsNumber { dup 48 ge exch dup 57 le 3 -1 roll and exch 46 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadNumber {
  exch dup 3 -1 roll dup 3 1 roll
  %%read mantissa
  { 1 add  2 copy dup Strlen eq { pop pop 0 exit } if get dup IsNumber not { exit } if pop } loop
  dup 101 eq exch 69 eq or
  %%% there is a "e" or "E" -> read exponant
  { 1 add 2 copy get dup IsUnaryOp
    { pop 1 add 2 copy get } if
    { IsNumber not { exit } if 1 add 2 copy get } loop }
  if
  dup 4 1 roll
  3 -1 roll exch 1 index sub getinterval
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsCondOp { dup 30 eq exch dup 60 ge exch 62 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadCondOp {
  NextNonBlankChar 1 index 4 1 roll
  { IsCondOp not { exit } if 1 add  2 copy get } loop
  2 copy 5 -1 roll
  exch 1 index sub getinterval 3 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can contain only : 0123456789.
%% chr -> T/F
/IsLiteral {%
  dup 48 ge exch dup  57 le 3 -1 roll and exch
  dup 65 ge exch dup  90 le 3 -1 roll and 3 -1 roll or exch
  dup 97 ge exch     122 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can be of the form [a-zA-Z][a-zA-Z0-9]*\(\((Expression)\)|\(\[Expression\]\)\)?
%% STR index -> literal STR index' nextchr
/ReadLiteral {
  exch dup 3 -1 roll dup 3 1 roll
  %%read literal core
  { 2 copy dup Strlen eq { pop pop 0 exit } if get dup IsLiteral not { exit } if pop 1 add } loop
  4 1 roll dup 5 1 roll 3 -1 roll exch 1 index sub getinterval 4 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a clpar
%% STR index -> STR index STR[index] T/F
/IsEndingExpr {%
  2 copy dup Strlen eq
  %% if end of str is reached -> end !
  { pop pop 0 true }
  %% ending chr -> clpar, comma, |, <, >, =, !,
  {get dup  dup  41 eq
       exch dup 124 eq
       exch dup  93 eq
       exch dup  44 eq
       exch dup  30 eq
       exch dup  60 ge exch 62 le and or or or or or}
  ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a +-
%% STR index -> STR index STR[index] T/F
/IsEndingTerm { IsEndingExpr { true } { dup dup 43 eq exch 45 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or */
%% STR index -> STR index STR[index] T/F
/IsEndingFactor { IsEndingTerm { true } { dup dup 42 eq exch 47 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or ^
%% STR index -> STR index STR[index] T/F
/IsEndingPower { IsEndingFactor { true } { dup 94 eq } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index STR[index]
/NextNonBlankChar { { dup Strlen eq { 0 exit } if 2 copy get dup neBlkChar { exit } if pop 1 add } loop } bind def
/neBlkChar { dup 32 ne exch dup 10 ne exch 9 ne and and } bind def
%%%%%%%%%%%%%%%%%%%%%%%%
%% DEBUG
/BRK {false} def
/BRKtrue {/BRK true def} def
/BRKStop {BRK {BRKtoto} if } def
/BRKEvalStop {BRK exch if } def
/BRKBRK2true {BRK {BRK2true} if } def
/BRK2 {false} def
/BRK2true {/BRK2 true def} def
/BRK2Stop {BRK2 {BRK2toto} if } def/BRK {false} def
end
%
%-------------------------------------------------------------------------------%
%
/tx@AlgToPs 12 dict def tx@AlgToPs begin
%
%% algExpr -> PSVector
/AlgToPs { tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE pop pop EndingSequence end } def
/EndingSequence { ExpressionVector aload length /end cvx exch 1 add array astore } def
/InitParser { /ExpressionVector [ /tx@AddMathFunc cvx /begin cvx ] def dup length /Strlen exch def 0 } def
/Strlen 0 def
/EvalListOfExpr {} def%
/EvalNumber {%
    ReadNumber  cvr /ExpressionVector ExpressionVector aload length dup 3 add -1 roll cvx
    exch 1 add array astore def NextNonBlankChar pop } def
/EvalAddSub {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  43 eq { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
/EvalMulDiv {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  42 eq { /mul } { /div } ifelse cvx exch 1 add array astore def
} def
/EvalPower {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  pop /exp cvx exch 1 add array astore def
} def
/EvalFactorial {% DR 09/2011
  /ExpressionVector ExpressionVector aload length
  /fact cvx exch 1 add array astore def
} def
/EvalLiteral {%
  ReadLiteral
  dup 40 eq%%% there is an open par -> function call
  { pop 2 index
    dup (Sum) eq { EvalSum }
    { dup (IfTE) eq { EvalCond }
      { dup (Derive) eq { pop EvalDerive }
	{ pop 1 add NextNonBlankChar pop AnalyzeListOfE 2 index TrigoFunc
          /ExpressionVector ExpressionVector aload length dup 5 add -1 roll cvn cvx
	  exch 1 add array astore def 1 add NextNonBlankChar pop } ifelse } ifelse} ifelse }
  { /ExpressionVector ExpressionVector aload length dup 6 add -1 roll cvn cvx exch 1 add array astore def
    dup 91 eq%%% there is an open bracket -> vector element
    { pop 1 add NextNonBlankChar pop AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def 1 add }
    { pop NextNonBlankChar pop }
    ifelse}
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the derive function : Derive(n,f(x))
%% firstparindex lastparindex ->
/EvalDerive {
  %% manage the function descripiton
  1 add ReadNumber 3 1 roll NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  1 add NextNonBlankChar pop
  3 -1 roll cvi
  dup 0 eq
  { pop AnalyzeExpr 3 -1 roll pop 1 add }
  { 1 sub 3 1 roll (x)  exch tx@Derive begin DeriveIndexed end 4 -1 roll
    { (x) tx@Derive begin Derive end } repeat
    ExpressionVector exch /ExpressionVector [] def
    AlgToPs aload length
    /ExpressionVector 1 index 3 add -1 roll aload length dup 3 add -1 roll  /l2 exch def /l1 exch def
    l1 l2 add 1 add l2 neg roll l1 l2 add array astore def 3 -1 roll pop 1 add
    1 index length /Strlen exch def } ifelse
} def
/EvalSum {%
  pop 1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  /ExpressionVector ExpressionVector aload length dup 7 add -3 roll 0 4 1 roll
  5 -1 roll 4 add array astore def
  %% keep ExpressionVector for later and create a new one for internal Sum computation
  ExpressionVector 3 1 roll /ExpressionVector [ 6 -1 roll cvn /exch cvx /def cvx ] def
  1 add NextNonBlankChar pop AnalyzeExpr
  %% add each term
  /ExpressionVector ExpressionVector aload length 1 add /add cvx exch array astore def
  /ExpressionVector 4 -1 roll aload length ExpressionVector cvx /for cvx 3 -1 roll 2 add
  array astore def 3 -1 roll pop 1 add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length 3.1415926 /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
/EvalCond {%
  pop 1 add AnalyzeCond NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  ExpressionVector 3 1 roll /ExpressionVector [] def
  1 add AnalyzeExpr ExpressionVector 3 1 roll /ExpressionVector [] def
  NextNonBlankChar 44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add AnalyzeExpr
  NextNonBlankChar 41 ne { ANALYZER_ERROR_missing_ending parenthesis_in_IfTE } if
  ExpressionVector
  /ExpressionVector 6 -1 roll aload length dup
  6 add -1 roll cvx exch dup 4 add -1 roll cvx /ifelse cvx 3 -1 roll 3 add array astore def
  1 add 3 -1 roll pop
} def
%% CondOp STR index
/EvalCondOp {%
  3 -1 roll
  dup (=) eq  { /eq } {%
  dup (<) eq  { /lt } {%
  dup (>) eq  { /gt } {%
  dup (>=) eq { /ge } {%
  dup (<=) eq { /ge } {%
  dup (!=) eq { /ne } { ERROR_non_valid_conditional_operator }
  ifelse } ifelse } ifelse } ifelse } ifelse } ifelse
  cvx exch pop
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll exch 1 add array astore def } def
/EvalUnaryOp {
  3 -1 roll 45 eq { /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook {} bind def
/PreEvalHook {} bind def
/AnalyzeListOfEPostHook {} bind def
/AnalyzePostHook {} def
/RollOp { 3 1 roll } bind def
end   %tx@CoreAnalyzerDict
%
%--------------------------------------------------------------------%
%
/tx@Derive 41 dict def tx@Derive begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable -> PSVector
/Derive {
  10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE end
} def
/Strlen 0 def
/InitParser { dup length /Strlen exch def 0 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable index -> PSVector
/DeriveIndexed {%
  3 1 roll 10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser pop 4 -1 roll AnalyzeExpr 4 -2 roll pop pop 4 -2 roll exch pop end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u,v)'=-(u',v')
/EvalListOfExpr {%
  4 2 roll 2 copy 9 -1 roll dup length 4 1 roll putinterval add AddPipe
           2 copy 7 -1 roll dup length 4 1 roll putinterval add
  6 -2 roll pop pop
  2 copy pop 0 6 2 roll GetIntervalNewStr 5 1 roll 2 copy 0 exch getinterval 6 1 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (-u)'=-(u')
/EvalUnaryOp {
  4 -2 roll 4 index (0) eq
  { (0) StrConcat 7 -1 roll pop }
  { 7 -1 roll 45 eq
    { AddSub AddOpPar true } { false } ifelse
    3 1 roll 5 index StrConcat 3 -1 roll { AddClPar } if } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  7 -2 roll pop pop 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (number)'=0
/EvalNumber { ReadNumber (0) 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u+v)'=u'+v'
/EvalAddSub {%
  7 index dup (0) eq
  { pop true }%% du=0 nothing added
  { dup length exch 5 index 5 index 3 -1 roll putinterval 4 -1 roll add 3 1 roll false }
  ifelse
  5 index dup (0) eq
  { pop { (0) } { 4 -2 roll 2 copy pop 0  6 2 roll GetIntervalNewStr } ifelse }%%dv=0
  { exch
    { 5 -2 roll 7 index 45 eq { AddSub } if false } %%nothing yet added
    { 5 -2 roll 7 index 43 eq%%something yet added
      { AddAdd false } { AddSub AddOpPar true } ifelse }
    ifelse 11 1 roll
    3 -1 roll StrConcat 10 -1 roll { AddClPar } if
    2 copy pop 0 6 2 roll GetIntervalNewStr }
  ifelse
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)' or (u/v)'
/EvalMulDiv { 6 index 42 eq {EvalMul} {EvalDiv} ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)'=u'*v+u*v'
/EvalMul {%
  4 -2 roll 7 index dup (0) eq
  { pop false }%%du=0
  { (1) eq%%du=1
    { false }
    { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
    3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if
    true }%%du!=0
  ifelse
  5 1 roll 5 index (0) eq
  { 5 -1 roll not { (0) StrConcat } if }%%dv=0
  { 5 -1 roll { AddAdd } if
    4 index (1) eq
    { 8 index StrConcat }
    { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
    ifelse
  }%%dv!=0
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u/v)'=(u'*v-u*v')/v^2
/EvalDiv {%
  4 -2 roll
  4 index (0) eq%%dv=0 -> u'/v
  { 7 index (0) eq { (0) StrConcat } { AddOpPar 7 index StrConcat AddClPar AddDiv 5 index StrConcat } ifelse }
  { 7 index dup (0) eq
    { pop }%%du=0
    { (1) eq%%du=1
      { false }
      { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
      3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if}%%du!=0
    ifelse
      AddSub
      4 index (1) eq
      { 8 index StrConcat }
      { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
      ifelse
    %}%%dv!=0
    2 copy GetIntervalNewStr 3 1 roll pop 0 AddOpPar 3 -1 roll StrConcat AddClPar
    AddDiv AddOpPar 5 index StrConcat AddClPar 2 copy (^2) putinterval 2 add }
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str1 index str2 -> str1 index
/StrConcat { dup length 4 2 roll 2 copy 6 -1 roll putinterval 3 -1 roll add } bind def
/GetIntervalNewStr { 0 exch getinterval dup length string copy } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u^v)'=(u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
/EvalPower {%
  4 -2 roll 7 index (0) eq
  {%%if du=0 then (u^v)'=v'ln(u)u^v
    4 index (0) eq
    { (0) StrConcat }%%if dv=0 then (u^v)'=0
    { 4 index (1) ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if
      8 index (e) ne { (ln\() StrConcat 8 index StrConcat (\)*) StrConcat } if
      AddOpPar 8 index StrConcat (\)^\() StrConcat 5 index StrConcat AddClPar } ifelse
  }
  {%%du!=0
    4 index (0) eq
    {%%if dv=0 then (u^v)'=vu'u^(v-1)
      5 index dup IsStrNumber
      { dup (0) eq
        { StrConcat }
        { dup dup (1) eq exch (1.0) eq or
          { StrConcat  }
	  { StrConcat
	    7 index dup (1) ne exch (1.0) ne and%%%dr 09102006 insert du if <> 1
	    { (*\() StrConcat 7 index StrConcat (\)) StrConcat } if%%%dr 09102006
            (*\() StrConcat 8 index StrConcat (\)) StrConcat
            5 index  dup dup (2) eq exch (2.0) eq or
	    { pop } { cvr 1 sub 20 string cvs 3 1 roll (^) StrConcat 3 -1 roll StrConcat } ifelse } ifelse } ifelse }
      { pop AddOpPar 5 index StrConcat (\)*\() StrConcat 8 index StrConcat (\)^\() StrConcat
        5 index StrConcat (-1\)) StrConcat } ifelse
    }
    {%%if dv!=0 and du!=0 then (u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
      7 index (1) ne { AddOpPar 7 index StrConcat (\)*) StrConcat } if
      AddOpPar 5 index StrConcat (\)*\() StrConcat
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (-1\)+\() StrConcat
      4 index (1) ne { 4 index StrConcat (\)*\() StrConcat } if
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (\)*ln\() StrConcat
      8 index StrConcat AddClPar
    } ifelse
  } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for factorial ! only cst => null derivative
/EvalFactorial {% DR 09/2011
  4 index (0) eq
  { (0) mark 8 -2 roll  cleartomark 2 index 7 index dup 4 index exch sub getinterval exch 6 2 roll }
  { DERIVATIVE_ENGINE_ERROR_no_variable_in_factorial } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str -> true/false
/IsStrNumber {%
  true exch
  { dup 48 lt exch dup 57 gt 3 -1 roll or
    exch dup 46 ne%%.
    exch dup 43 ne%%+
    exch 45 ne%%-
    and and and { pop false } if } forall
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalLiteral {%
  ReadLiteral dup 40 eq%%% there is an open par -> function call
  { pop (EvalFunc_             ) 9 4 index StrConcat 0 exch getinterval cvn cvx exec }
  { dup 91 eq%%% there is an open bracket -> vector element
    { DERIVATIVE_ENGINE_ERROR_vector_not_yet_implemented }
    { pop EvalVariable }
    ifelse }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% first last parpos Expr[first:parpos-1] ->
/EvalVariable { 2 index Variable eq { (1) } { (0) } ifelse 4 -1 roll exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (f(u))'=u'f'(u)
/EvalFunc {
  4 2 roll 4 index (1) ne
  { AddOpPar 4 index StrConcat (\)*) StrConcat } if
  (Eval             ) 4 8 index StrConcat 0 exch getinterval cvn cvx exec
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Func derivative -> Eval<func>
/EvalFunc_sin {%
  PreCommonFunc
  { (cos\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_cos {%
  PreCommonFunc
  { (\(-sin\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_tan {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/cos\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_asin {%
  PreCommonFunc
  { (1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_acos {%
  PreCommonFunc
  { (-1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_atg {%
  PreCommonFunc
  { (1/\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_floor {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ln {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_exp {%
  PreCommonFunc
  {  (exp\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_EXP {%
  PreCommonFunc
  {  (EXP\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_sqrt {%
  PreCommonFunc
  { dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\(2*sqrt\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Fact {%
  PreCommonFunc { DERIVATIVE_ENGINE_ERROR_no_variable_expression_in_Fact } if
  PostCommonFunc } def
/EvalFunc_sh {%
  PreCommonFunc
  { (ch\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ch {%
  PreCommonFunc
  { (sh\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_th {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/ch\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argsh {%
  PreCommonFunc
  { (1/sqrt\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argch {%
  PreCommonFunc
  { (1/sqrt\(\() StrConcat 5 index StrConcat (\)^2-1\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argth {%
  PreCommonFunc
  { (1/\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PreCommonFunc {
  1 add NextNonBlankChar pop 3 -1 roll 5 1 roll AnalyzeExpr 1 add NextNonBlankChar pop
  4 2 roll 4 index (0) eq
  { (0) StrConcat false }
  { 4 index (1)  ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if true } ifelse
} def
/PostCommonFunc {
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
/EvalFunc_Derive {%
  1 add ReadNumber cvi 1 add dup cvr log 1 add cvi string cvs
  4 -1 roll pop 5 1 roll 1 add NextNonBlankChar pop AnalyzeExpr 1 add
  4 -2 roll (Derive\() StrConcat 7 -1 roll StrConcat (,) StrConcat 6 -1 roll StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr 6 -1 roll pop 2 index 6 index dup 4 index exch sub getinterval
  exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_Sum {%
  1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop 3 -1 roll pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_third_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_fourth_comma_in_Sum } if
  1 add NextNonBlankChar pop dup 6 1 roll 3 -1 roll pop AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 8 index dup 9 index exch sub getinterval StrConcat
  4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_IfTE {%
  3 -1 roll pop 1 add NextNonBlankChar pop SkipCond
  NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  1 add NextNonBlankChar pop dup 5 1 roll
  AnalyzeExpr NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add NextNonBlankChar pop
  AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 10 index dup 11 index exch sub getinterval StrConcat
  6 index StrConcat (,) StrConcat 4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% advance in str until a comma is found (no error detection!)
%% str index -> str index'
/SkipCond { { 1 add 2 copy get 44 eq {exit } if } loop } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for condition....
/EvalCondOp { 3 -1 roll pop } bind def
/PutIntervalOneAdd {putinterval 1 add} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddOpPar {2 copy (\() PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add close parenthesis in string at the given index
%% str index -> str index+1
/AddClPar {2 copy (\)) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add 0 in string at the given index
%% str index -> str index+1
/AddZero {2 copy (0) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddMul {2 copy (*) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddDiv {2 copy (/) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a plus sign in string at the given index
%% str index -> str index+1
/AddAdd {2 copy (+) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a minus sign in string at the given index
%% str index -> str index+1
/AddSub {2 copy (-) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a pipe sign in string at the given index
%% str index -> str index+1
/AddPipe {2 copy (|) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook { dup 5 1 roll } bind def
/PreEvalHook {} def
/AnalyzePostHook { 7 -1 roll pop } bind def
/AnalyzeListOfEPostHook { 6 -1 roll mark 6 1 roll cleartomark } bind def
/RollOp { 5 1 roll } bind def
end%%%tx@CoreAnalyzerDict
/tx@AddMathFunc 12 dict def tx@AddMathFunc begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% function arcsine in radians asin(x)=atan(x/sqrt(1-x^2))
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup dup dup mul 1 exch sub sqrt atan exch 0 lt { 360 sub } if DegtoRad
} def
%% function arccosine in radians acos(x)=atan(sqrt(1-x^2)/x)
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup dup mul 1 exch sub sqrt exch atan DegtoRad
} def
%% function arctangent in radians
%% x -> theta
/atg { 1 atan dup 90 gt { 360 sub } if DegtoRad } bind def
%% HYPERBOLIC FUNCTIONS
/sh { dup Ex exch neg Ex sub 2 div } def
/ch { dup Ex exch neg Ex add 2 div } def
/th { dup sh exch ch div } def
/Argsh { dup dup mul 1 add sqrt add ln } def
/Argch { dup dup mul 1 sub sqrt add ln } def
/Argth { dup 1 add exch 1 exch sub div ln 2 div } def
%% modified exponential funtion for 0
%% x n -> x^n
/Exp { dup 0 eq { pop pop 1 } { exp } ifelse } bind def
%% modified exponential funtion for 0
%% x -> e^x
/Ex { Euler exch exp } bind def
%%
%% factorial function
%% n -> n!
/Fact { 1 exch 2 exch 1 exch { mul } for } bind def
/fact { Fact } bind def
/! { Fact } bind def
end
%
% END pst-algparser.pro

% $Id: pst-tools.pro 842 2013-10-26 10:25:41Z herbert $
%
%% PostScript tools prologue for pstricks.tex.
%% Version 0.04, 2013/10/26
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
/Pi2 1.57079632679489661925640 def
/factorial { % n on stack, returns n! 
  dup 0 eq { 1 }{ 
    dup 1 gt { dup 1 sub factorial mul } if }
  ifelse } def 
%
/MoverN { % m n on stack, returns the binomial coefficient m over n
  2 dict begin
  /n exch def /m exch def
  n 0 eq { 1 }{
    m n eq { 1 }{
      m factorial n factorial m n sub factorial mul div } ifelse } ifelse 
  end
} def
%
/ps@ReverseOrderOfPoints { % on stack [P1 P2 P3 ...Pn]=>[Pn,Pn-1,...,P2,P1]
  5 dict begin       % all local
  aload length /n ED % number of coors
  n 2 div cvi /m ED  % number of Points
  /n1 n def
  m { n1 2 roll /n1 n1 2 sub def } repeat
  n array astore
  end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% subroutines for complex numbers, given as an array [a b] 
% which is a+bi = Real+i Imag
%
/cxadd {		% [a1 b1] [a2 b2] = [a1+a2 b1+b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  3 -1 roll		% [a2 b2] a2 [a1 b1]
  dup 0 get		% [a2 b2] a2 [a1 b1] a1
  3 -1 roll		% [a2 b2] [a1 b1] a1 a2
  add			% [a2 b2] [a1 b1] a1+a2
  3 1 roll		% a1+a2 [a2 b2] [a1 b1]
  1 get			% a1+a2 [a2 b2] b1
  exch 1 get		% a1+a2 b1 b2
  add 2 array astore
} def
%
/cxneg {		% [a b]
  dup 1 get		% [a b] b
  exch 0 get		% b a
  neg exch neg		% -a -b
  2 array astore
} def
%
/cxsub { cxneg cxadd } def  % same as negative addition
%
% [a1 b1][a2 b2] = [a1a2-b1b2 a1b2+b1a2] = [a3 b3]
/cxmul {		% [a1 b1] [a2 b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  exch 1 get		% [a1 b1] a2 b2
  3 -1 roll		% a2 b2 [a1 b1]
  dup 0 get		% a2 b2 [a1 b1] a1
  exch 1 get		% a2 b2 a1 b1
  dup			% a2 b2 a1 b1 b1
  5 -1 roll dup		% b2 a1 b1 b1 a2 a2
  3 1 roll mul		% b2 a1 b1 a2 b1a2
  5 -2 roll dup		% b1 a2 b1a2 b2 a1 a1
  3 -1 roll dup		% b1 a2 b1a2 a1 a1 b2 b2
  3 1 roll mul		% b1 a2 b1a2 a1 b2 a1b2
  4 -1 roll add		% b1 a2 a1 b2 b3
  4 2 roll mul		% b1 b2 b3 a1a2
  4 2 roll mul sub	% b3 a3
  exch 2 array astore
} def
%
% [a b]^2 = [a^2-b^2 2ab] = [a2 b2]
/cxsqr {		% [a b]   square root
  dup 0 get exch 1 get	% a b
  dup dup mul		% a b b^2
  3 -1 roll		% b b^2 a
  dup dup mul 		% b b^2 a a^2
  3 -1 roll sub		% b a a2
  3 1 roll mul 2 mul	% a2 b2	
  2 array astore
} def
%
/cxsqrt {		% [a b]
%  dup cxnorm sqrt /r exch def
%  cxarg 2 div RadtoDeg dup cos r mul exch sin r mul cxmake2 
  cxlog 		% log[a b]
  2 cxrdiv 		% log[a b]/2
  aload pop exch	% b a
  2.781 exch exp	% b exp(a)
  exch cxconv exch	% [Re +iIm] exp(a)
  cxrmul		%
} def
%
/cxarg { 		% [a b] 
  aload pop 		% a b
  exch atan 		% arctan b/a
  DegtoRad 		% arg(z)=atan(b/a)
} def
%
% log[a b] = [a^2-b^2 2ab] = [a2 b2]
/cxlog {		% [a b]
  dup 			% [a b][a b]
  cxnorm 		% [a b] |z|
  log 			% [a b] log|z|
  exch 			% log|z|[a b]
  cxarg 		% log|z| Theta
  cxmake2 		% [log|z| Theta]
} def
%
% square of magnitude of complex number
/cxnorm2 {		% [a b]
  dup 0 get exch 1 get	% a b
  dup mul			% a b^2
  exch dup mul add	% a^2+b^2
} def
%
/cxnorm {		% [a b]
  cxnorm2 sqrt
} def
%
/cxconj {		% conjugent complex
  dup 0 get exch 1 get	% a b
  neg 2 array astore	% [a -b]
} def
%
/cxre { 0 get } def	% real value
/cxim { 1 get } def	% imag value
%
% 1/[a b] = ([a -b]/(a^2+b^2)
/cxrecip {		% [a b]
  dup cxnorm2 exch	% n2 [a b]
  dup 0 get exch 1 get	% n2 a b
  3 -1 roll		% a b n2
  dup			% a b n2 n2
  4 -1 roll exch div	% b n2 a/n2
  3 1 roll div		% a/n2 b/n2
  neg 2 array astore
} def
%
/cxmake1 { 0 2 array astore } def % make a complex number, real given
/cxmake2 { 2 array astore } def	  % dito, both given
%
/cxdiv { cxrecip cxmul } def
%
% multiplikation by a real number
/cxrmul {		% [a b] r
  exch aload pop	% r a b
  3 -1 roll dup		% a b r r
  3 1 roll mul		% a r b*r
  3 1 roll mul		% b*r a*r
  exch 2 array astore   % [a*r b*r]
} def
%
% division by a real number
/cxrdiv {		% [a b] r
  1 exch div		% [a b] 1/r
  cxrmul
} def
%
% exp(i theta) = cos(theta)+i sin(theta) polar<->cartesian
/cxconv {		% theta
  RadtoDeg dup sin exch cos cxmake2
} def

%%%%% ### bubblesort ###
%% syntax : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort { % on stack must be an array [ ... ]
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a % return the sorted array
end
} def
%
/concatstringarray{  %  [(a) (b) ... (z)] --> (ab...z)  20100422
  0 1 index { length add } forall 
  string     
  0 3 2 roll      
  { 3 copy putinterval length add }forall 
  pop  
} bind def
%
/dot2comma {% on stack a string (...) 
  2 dict begin
  /Output exch def
  0 1 Output length 1 sub { 
    /Index exch def 
    Output Index get 46 eq { Output Index 44 put } if 
  } for
  Output
  end
} def
%
/rightTrim { % on stack the string and the character number to be stripped  
  /charNo exch def
  dup
  length 1 sub -1 0 { 
    /i exch def dup i get charNo ne { exit } if 
  } for
  0 i 1 add getinterval
  dup length string copy
} bind def  % leaves the stripped string on the stack

/psStringwidth /stringwidth load def
/psShow /show load def

%/stringwidth{ 32 rightTrim psStringwidth } bind def

%/show { 32 rightTrim psShow } bind def
%-----------------------------------------------------------------------------%

/pgffunctions {
    /pgfsc{}bind def% stroke color is empty by default
    /pgffc{}bind def% fill color is empty by default
    /pgfstr{stroke}bind def%
    /pgffill{fill}bind def%
    /pgfeofill{eofill}bind def%
    /pgfe{a dup 0 rlineto exch 0 exch rlineto neg 0 rlineto closepath}bind def% rectangle
    /pgfw{setlinewidth}bind def% setlinewidth
    /pgfs{save pgfpd 72 Resolution div 72 VResolution div neg scale 
      magscale{1 DVImag div dup scale}if 
      pgfx neg pgfy neg translate pgffoa .setopacityalpha}bind def% save
    /pgfr{pgfsd restore}bind def %restore
    userdict begin%
    /pgfo{pgfsd /pgfx currentpoint /pgfy exch def def @beginspecial}bind def %open
    /pgfc{newpath @endspecial pgfpd}bind def %close
    /pgfsd{globaldict /pgfdelta /delta where {pop delta} {0} ifelse put}bind def% save delta
    /pgfpd{/delta globaldict /pgfdelta get def}bind def % put delta
    /.setopacityalpha where {pop} {/.setopacityalpha{pop}def} ifelse % install .setopacityalpha 
    /.pgfsetfillopacityalpha{/pgffoa exch def
      /pgffill{gsave pgffoa .setopacityalpha fill 1 .setopacityalpha newpath fill grestore newpath}bind def
      /pgfeofill{gsave pgffoa .setopacityalpha eofill 1 .setopacityalpha newpath eofill grestore newpath}bind def}bind def
    /.pgfsetstrokeopacityalpha{/pgfsoa exch def /pgfstr{gsave pgfsoa .setopacityalpha stroke grestore newpath}bind def}bind def
    /pgffoa 1 def
    /pgfsoa 1 def
    end
} def
%-----------------------------------------------------------------------------%
% END pst-tools.pro

% $Id: pst-dots.pro 801 2013-07-09 18:10:41Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 2.02,  2009/06/16
%%
%% For distribution, see pstricks.tex.
%%
%% Timothy Van Zandt <tvz@Princeton.EDU>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% Modified by Etienne Riga  - Dec. 16, 1999
%% Modified by Etienne Riga  - 2005/01/01 (er)
%% to add /Diamond, /SolidDiamond and /BoldDiamond
%% Modified by Herbert Voss (hv) - 2008/04/17 
%
10 dict dup begin			% hold local
  /FontType 3 def
  /FontMatrix [.001 0 0 .001 0 0] def
%  /FontBBox [-571.5 -742.5 571.5 742.5] def % changed to next line 20060616 hv
  /FontBBox [-1000 -1000 1000 1000] def  % See end of file in /BuildGlyph
  /Encoding 256 array def
  0 1 255 {Encoding exch /.notdef put} for % fill the array with /.notdef
  Encoding				   % replace with given dot names
    dup (b) 0 get /Bullet put		   % get the numerical position of b in ASCII
%					   % and save /Bullet at this place in Encoding 
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put	% 67
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
%%%		  
    dup (k) 0 get /Asterisk put
    dup (K) 0 get /BoldAsterisk put
    dup (J) 0 get /SolidAsterisk put
    dup (h) 0 get /Hexagon put
    dup (H) 0 get /BoldHexagon put
    dup (G) 0 get /SolidHexagon put
    dup (f) 0 get /Octogon put		% 2008-04-18 hv
    dup (F) 0 get /BoldOctogon put	% 2008-04-18 hv
    dup (g) 0 get /SolidOctogon put	% 2008-04-18 hv
    dup (a) 0 get /Add put
    dup (A) 0 get /BoldAdd put 		% 65
    dup (x) 0 get /Mul put
    dup (X) 0 get /BoldMul put
    dup (m) 0 get /Oplus put
    dup (M) 0 get /BOplus put
    dup (e) 0 get /SolidOplus put
    dup (n) 0 get /Otimes put
    dup (N) 0 get /BOtimes put
    dup (E) 0 get /SolidOtimes put
    dup (i) 0 get /Bar put
    dup (I) 0 get /BoldBar put
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
%%%  
/CharProcs 47 dict def
CharProcs begin
  /CirclePath {0 0 500 0 360 arc closepath} def
  /Bullet {CirclePath fill} def
  /Circle {CirclePath .9 .9 scale CirclePath eofill} def
  /BoldCircle {CirclePath .8 .8 scale CirclePath eofill} def
  /TrianglePath {0 660 moveto -571.5 -330 lineto 571.5 -330 lineto closepath} def
  /SolidTriangle {TrianglePath fill} def
  /Triangle {TrianglePath .85 .85 scale TrianglePath eofill} def
  /BoldTriangle {TrianglePath .7 .7 scale TrianglePath eofill} def
  /SquarePath {-450 450 moveto 450 450 lineto 450 -450 lineto -450 -450 lineto closepath} def
  /SolidSquare {SquarePath fill} def
  /Square {SquarePath .89 .89 scale SquarePath eofill} def
  /BoldSquare {SquarePath .78 .78 scale SquarePath eofill} def
  /PentagonPath {
    -337.8 -465 moveto 337.8 -465 lineto 546.6 177.6 lineto
    0 574.7 lineto -546.6 177.6 lineto closepath
  } def
  /SolidPentagon {PentagonPath fill} def
  /Pentagon {PentagonPath .89 .89 scale PentagonPath eofill} def
  /BoldPentagon {PentagonPath .78 .78 scale PentagonPath eofill} def
%-------------- hv begin 2004/07/25   from: er 2003/03/24
  /HexagonPath {
    0 550 moveto -476 275 lineto -476 -275 lineto
    0 -550 lineto 476 -275 lineto 476 275 lineto closepath
  } def
  /SolidHexagon {HexagonPath fill} def
  /Hexagon {HexagonPath .89 .89 scale HexagonPath eofill} def
  /BoldHexagon {HexagonPath .79 .79 scale HexagonPath eofill} def
%					2008-04-18 hv
  /OctogonPath { 
     550 dup 22.5 tan mul dup neg dup add /xMove exch def 
     exch moveto 7 { xMove 0 rlineto 45 rotate } repeat closepath } def 
  /SolidOctogon { OctogonPath fill                             } def
  /Octogon {      OctogonPath .89 .89 scale OctogonPath eofill } def
  /BoldOctogon {  OctogonPath .79 .79 scale OctogonPath eofill } def
%
  /AsteriskPath {
    20 0 moveto 10 250 180 500 0 500 curveto
    -180 500 -10 250 -20 0 curveto closepath
  } def
  /Asterisk {
    AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath
    60 rotate AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath fill
  } def
%
  /Basterp {50 250 220 500 0 500 curveto -220 500 -50 250 -50 30 cos 100 mul curveto} def
  /BoldAsteriskPath {
    50 30 cos 100 mul moveto  Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp closepath
  } def
  /BoldAsterisk {BoldAsteriskPath fill} def
  /SolidAsterisk {CirclePath .9 .9 scale BoldAsteriskPath eofill} def
  /CrossPath {
    40 550 moveto -40 550 lineto -40 40 lineto -550 40 lineto
    -550 -40 lineto -40 -40 lineto -40 -550 lineto 40 -550 lineto 
    40 -40 lineto 550 -40 lineto 550 40 lineto 40 40 lineto closepath
  } def
  /BoldCrossPath {80 550 moveto -80 550 lineto -80 80 lineto -550 80 lineto
    -550 -80 lineto -80 -80 lineto -80 -550 lineto 80 -550 lineto 
    80 -80 lineto 550 -80 lineto 550 80 lineto 80 80 lineto closepath
  } def
  /Add {CrossPath fill} def
  /Mul {45 rotate CrossPath fill} def
  /BoldAdd {BoldCrossPath fill} def
  /BoldMul {45 rotate BoldCrossPath fill} def
  /Oplus {CirclePath .9 .9 scale CirclePath eofill .775 .775 scale CrossPath fill } def 
  /SolidOplus {CirclePath .775 .775 scale BoldCrossPath eofill} def 
  /BOplus {CirclePath .8 .8 scale CirclePath eofill .775 .775 scale BoldCrossPath fill} def 
  /Otimes {CirclePath .9 .9 scale CirclePath eofill 45 rotate .775 .775 scale CrossPath fill} def 
  /BOtimes {CirclePath .8 .8 scale CirclePath eofill 45 rotate .775 .775 scale BoldCrossPath fill } def 
  /SolidOtimes {CirclePath 45 rotate .775 .775 scale BoldCrossPath eofill} def 
  /BarPath {40 660 moveto -40 660 lineto -40 -660 lineto 40 -660 lineto closepath} def
  /Bar {BarPath fill} def
  /BoldBarPath {80 660 moveto -80 660 lineto -80 -660 lineto 80 -660 lineto closepath} def
  /BoldBar {BoldBarPath fill} def
  /DiamondPath {0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto 428.5 0 lineto closepath} def
  /SolidDiamond {DiamondPath fill} def
  /Diamond {DiamondPath .865 .865 scale DiamondPath eofill} def
  /BoldDiamond {DiamondPath .73 .73 scale DiamondPath eofill} def
%%%
  /.notdef { } def
end
%
/BuildGlyph {
  exch
  begin 		
%  Metrics 1 index get exec 0
    0 0
%      BBoxes 3 index get exec
    -1000 -1000 1000 1000
%     -571.5 -742.5 571.5 742.5
    setcachedevice
    CharProcs begin load exec end
  end
} def
%
/BuildChar {
  1 index /Encoding get exch get
  1 index /BuildGlyph get exec
} bind def
%
end
/PSTricksDotFont exch definefont pop
%
%% end

%!
% PostScript prologue for pst-grad.tex.
% Version 1.05, 2006/11/04 
% prepared by Herbert Voss
% For copying restrictions, see pstricks.tex.
%
% For the PSTricks gradient fillstyle.%
% Based on some EPS files by leeweyr!bill@nuchat.sccsi.com (W. R. Lee).%
% Syntax:% D.G. modification begin - Apr.  9, %1998
%%%%%% R0 G0 B0 R1 G1 B1 NumLines MidPoint Angle GradientFill
%   ifGradientCircle GradientScale %GradientPosX GradientPosY
%     R0 G0 B0 R1 G1 B1 NumLines MidPoint %Angle GradientFill
% D.G. modification end
%
/tx@GradientDict 40 dict def
tx@GradientDict begin
/GradientFill {
 /ifCMYK exch def   % do we have rgb or cmyk? hv 1.06
 rotate
 /MidPoint ED
 /NumLines ED
 ifCMYK {
    /LastBlack ED	% 1.06
    /LastYellow ED	% 1.06
    /LastMagenta ED	% 1.06
    /LastCyan ED	% 1.06
    /FirstBlack ED	% 1.06
    /FirstYellow ED	% 1.06
    /FirstMagenta ED	% 1.06
    /FirstCyan ED	% 1.06
 }{ /LastBlue ED
    /LastGreen ED
    /LastRed ED
    /FirstBlue ED
    /FirstGreen ED
    /FirstRed ED
 } ifelse
 /GradientPosY ED
 /GradientPosX ED
 /GradientScale ED
 /ifGradientCircle ED
 % This avoids gaps due to rounding errors:
 clip
 pathbbox           %leave llx,lly,urx,ury on stack
 4 copy /ury ED /urx ED /lly ED /llx ED
 /y ED /x ED
 ifGradientCircle
   { 0 GradientPosX eq { 0 GradientPosX eq {2 copy translate} if } if }
   {2 copy translate} ifelse
 y sub neg /y ED
 x sub neg /x ED  % This avoids gaps due to rounding errors:
 ifCMYK {				% 1.06
    LastCyan FirstCyan add 2 div	% 1.06
    LastMagenta FirstMagenta add 2 div	% 1.06
    LastYellow FirstYellow add 2 div	% 1.06
    LastBlack FirstBlack add 2 div	% 1.06
    setcmykcolor			% 1.06
  }{
    LastRed FirstRed add 2 div
    LastGreen FirstGreen add 2 div
    LastBlue FirstBlue add 2 div
    setrgbcolor
  } ifelse
 ifGradientCircle
   { /YSizePerLine y NumLines div def
     /CurrentY y 2 div def
     /MidLine NumLines 2 div 1 MidPoint sub mul abs cvi def
   }{
     fill
     /YSizePerLine y NumLines div def
     /CurrentY 0 def
     /MidLine NumLines 1 MidPoint sub mul abs cvi def
   } ifelse
 MidLine NumLines 2 sub gt 
   { /MidLine NumLines def }
   { MidLine 2 lt { /MidLine 0 def } if } ifelse
 MidLine 0 gt {
  ifCMYK {
    /Cyan FirstCyan def
    /Magenta FirstMagenta def
    /Yellow FirstYellow def
    /Black FirstBlack def
    /CyanIncrement LastCyan FirstCyan sub MidLine 1 sub div def
    /MagentaIncrement LastMagenta FirstMagenta sub MidLine 1 sub div def
    /YellowIncrement LastYellow FirstYellow sub MidLine 1 sub div def
    /BlackIncrement LastBlack FirstBlack sub MidLine 1 sub div def
  }{
    /Red FirstRed def
    /Green FirstGreen def
    /Blue FirstBlue def
    /RedIncrement LastRed FirstRed sub MidLine 1 sub div def
    /GreenIncrement LastGreen FirstGreen sub MidLine 1 sub div def
    /BlueIncrement LastBlue FirstBlue sub MidLine 1 sub div def
  } ifelse
  MidLine { GradientLoop } repeat
 } if
 MidLine NumLines lt {
  ifCMYK {
    /Cyan LastCyan def
    /Magenta LastMagenta def
    /Yellow LastYellow def
    /Black LastBlack def
    /CyanIncrement FirstCyan LastCyan sub NumLines MidLine sub 1 sub div def
    /MagentaIncrement FirstMagenta LastMagenta sub NumLines MidLine sub 1 sub div def
    /YellowIncrement FirstYellow LastYellow sub NumLines MidLine sub 1 sub div def
    /BlackIncrement FirstBlack LastBlack sub NumLines MidLine sub 1 sub div def
  }{
    /Red LastRed def
    /Green LastGreen def
    /Blue LastBlue def
    /RedIncrement FirstRed LastRed sub NumLines MidLine sub 1 sub div def
    /GreenIncrement FirstGreen LastGreen sub NumLines MidLine sub 1 sub div def
    /BlueIncrement FirstBlue LastBlue sub NumLines MidLine sub 1 sub div def
  } ifelse
  NumLines MidLine sub { GradientLoop } repeat  
 } if
} def/GradientLoop {
% D.G. modification begin - Jul. 23, 1997 / Apr.  9, 1998
  ifGradientCircle
   {CurrentY 0 gt {
% The default center used is the center of the bounding box of the object
      0 GradientPosX eq        {0 GradientPosX eq
           {/GradientPosX urx llx sub 2 div def
            /GradientPosY ury lly sub 2 div def} if} if
      GradientPosX GradientPosY CurrentY GradientScale mul 0 360 arc
      ifCMYK { Cyan Magenta Yellow Black setcmykcolor }
           { Red Green Blue setrgbcolor } ifelse 
      fill
      /CurrentY CurrentY YSizePerLine sub def
      ifCMYK {
        /Cyan Cyan CyanIncrement add def
        /Magenta Magenta MagentaIncrement add def
        /Yellow Yellow YellowIncrement add def
        /Black Black BlackIncrement add def
      }{	
        /Blue Blue BlueIncrement add def
        /Green Green GreenIncrement add def
        /Red Red RedIncrement add def
      } ifelse
  } if }   { 0 CurrentY moveto    x 0 rlineto
    0 YSizePerLine rlineto    x neg 0 rlineto    closepath
      ifCMYK { Cyan Magenta Yellow Black setcmykcolor }
           { Red Green Blue setrgbcolor } ifelse 
      fill    
      /CurrentY CurrentY YSizePerLine add def
      ifCMYK {
        /Cyan Cyan CyanIncrement add def
        /Magenta Magenta MagentaIncrement add def
        /Yellow Yellow YellowIncrement add def
        /Black Black BlackIncrement add def
      }{	
        /Blue Blue BlueIncrement add def
        /Green Green GreenIncrement add def
        /Red Red RedIncrement add def
      } ifelse
      } ifelse% D.G. modification end
    }def
%
/GradientFillHSB { %	hv 2006-11-04
  rotate
  /MidPoint ED
  /NumLines ED
  /LastBrightness ED
  /LastSaturation ED
  /LastHue ED
  /FirstBrightness ED
  /FirstSaturation ED
  /FirstHue ED
  % This avoids gaps due to rounding errors:
  clip
  pathbbox           %leave llx,lly,urx,ury on stack
  /y ED /x ED
  2 copy translate
  y sub neg /y ED
  x sub neg /x ED
  % This avoids gaps due to rounding errors:
  LastHue FirstHue add 2 div
  LastSaturation FirstSaturation add 2 div
  LastBrightness FirstBrightness add 2 div
  sethsbcolor
  fill
  /YSizePerLine y NumLines div def
  /CurrentY 0 def
  /MidLine NumLines 1 MidPoint sub mul abs cvi def
  MidLine NumLines 2 sub gt
  { /MidLine NumLines def }
  { MidLine 2 lt { /MidLine 0 def } if }
  ifelse
  MidLine 0 gt
  {
    /Hue FirstHue def
    /Saturation FirstSaturation def
    /Brightness FirstBrightness def
    /HueIncrement LastHue FirstHue sub MidLine 1 sub div def
    /SaturationIncrement LastSaturation FirstSaturation sub MidLine 1 sub
                         div def
    /BrightnessIncrement LastBrightness FirstBrightness sub MidLine 1 sub
                         div def
    MidLine { GradientLoopHSB } repeat
  } if
  MidLine NumLines lt
  {
    /Hue LastHue def
    /Saturation LastSaturation def
    /Brightness LastBrightness def
    /HueIncrement FirstHue LastHue sub NumLines MidLine sub 1 sub div def
    /SaturationIncrement FirstSaturation LastSaturation sub
                         NumLines MidLine sub 1 sub div def
    /BrightnessIncrement FirstBrightness LastBrightness sub
                         NumLines MidLine sub 1 sub div def
    NumLines MidLine sub { GradientLoopHSB } repeat
  } if
} def
/GradientLoopHSB {
  0 CurrentY moveto
  x 0 rlineto
  0 YSizePerLine rlineto
  x neg 0 rlineto
  closepath
  Hue Saturation Brightness sethsbcolor fill
  /CurrentY CurrentY YSizePerLine add def
  /Brightness Brightness BrightnessIncrement add def
  /Saturation Saturation SaturationIncrement add def
  /Hue Hue HueIncrement add def
} def
%
end
%
% END pst-grad.pro

% $Id: pst-node.pro 40 2014-07-25 06:46:27Z herbert $
%%
%% PostScript prologue for pst-node.tex.
%% Version 1.15, 2014/01/27.
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%%%%  EMPTY lines are not aload!!! Problem with pst-eps -> \par
%
%
tx@Dict begin 			% from main pstricks dict
 /T /translate load def 
 /CP /currentpoint load def 
% /startGlobal { true setglobal globaldict begin } bind def
% /endGlobal { end false setglobal } bind def
end
/tx@NodeDict 400 dict def tx@NodeDict begin
/NewNode { % on stack: { x y } boolean N@name type InitXnode 
  gsave 
  NodeScale                     % a bugfix for xelatex, it's empty for dvips
  /next exch def 		% { x y } boolean N@name type  
  dict dup 			% { x y } boolean N@name dict dict
  3 1 roll def 			% { x y } boolean dict N@name dict def
  exch { dup 3 1 roll def } if  % { x y } dict boolean
  begin 			% { x y } dict begin
  tx@Dict begin 
    STV CP T exec 		% set scaling
  end 
  /NodeMtrx CM def 		% save CM
  next 				% InitXNode
  end
  grestore 
} def
%
/InitPnode { 
  /Y ED /X ED 
  /NodePos { NodeSep Cos mul NodeSep Sin mul } def
} def
%
/InitCnode { 
  /r ED /Y ED /X ED 
  /NodePos { NodeSep r add dup Cos mul exch Sin mul } def 
} def
%
/GetRnodePos { 
  Cos 0 gt { /dx r NodeSep add def } { /dx l NodeSep sub def } ifelse 
  Sin 0 gt { /dy u NodeSep add def } { /dy d NodeSep sub def } ifelse 
  dx Sin mul abs dy 
  Cos mul abs gt { dy Cos mul Sin div dy } { dx dup Sin mul Cos Div } ifelse 
} def
%
/InitRnode { 
  /Y ED /X ED X sub /r ED /l X neg def Y add neg /d ED Y sub /u ED 
  /NodePos { GetRnodePos } def 
} def
%
/DiaNodePos { 
  w h mul w Sin mul abs h Cos mul abs add Div NodeSep add dup
  Cos mul exch Sin mul 
} def
%
/TriNodePos { 
  Sin s lt 
    { d NodeSep sub dup Cos mul Sin Div exch } 
    { w h mul w Sin mul h Cos abs mul add Div 
      NodeSep add dup Cos mul exch Sin mul 
    } ifelse 
} def
%
/InitTriNode { 
  sub 2 div exch 
  2 div exch 
  2 copy T 
  2 copy 4 index index /d ED 
  pop pop pop pop 
  -90 mul rotate 
  /NodeMtrx CM def 
  /X 0 def /Y 0 def 
  d sub abs neg /d ED 
  d add /h ED 
  2 div h mul h d sub Div /w ED 
  /s d w Atan sin def 
  /NodePos { TriNodePos } def 
} def
%
/OvalNodePos { 
  /ww w NodeSep add def 
  /hh h NodeSep add def 
  Sin ww mul Cos hh mul Atan dup cos ww mul exch sin hh mul 
} def
%
/GetCenter { begin X Y NodeMtrx transform CM itransform end } def
%
/XYPos { 
  dup sin exch cos Do 
  /Cos ED /Sin ED /Dist ED 
  Cos 0 gt 
    { Dist Dist Sin mul Cos div }
    { Cos 0 lt 
      { Dist neg Dist Sin mul Cos div neg }
      { 0 Dist Sin mul } ifelse 
    } ifelse 
  Do 
} def
%
/GetEdge {
  dup 0 eq 
    { pop begin 1 0 NodeMtrx dtransform 
      CM idtransform 
      exch atan sub 
      dup 
      sin /Sin ED 
      cos /Cos ED 
      /NodeSep ED 
      NodePos NodeMtrx dtransform CM idtransform end }
    { 1 eq {{exch}} {{}} ifelse /Do ED pop XYPos } ifelse 
} def
%
/AddOffset { 
  1 index 0 eq 
    { pop pop } 
    { 2 copy 5 2 roll cos mul add 4 1 roll sin mul sub exch } ifelse 
} def
%
/GetEdgeA { 
  NodeSepA AngleA NodeA NodeSepTypeA GetEdge 
  OffsetA AngleA AddOffset 
  yA add /yA1 ED 
  xA add /xA1 ED 
} def
%
/GetEdgeB { 
  NodeSepB AngleB NodeB NodeSepTypeB GetEdge 
  OffsetB AngleB AddOffset 
  yB add /yB1 ED 
  xB add /xB1 ED 
} def
%
/GetArmA { 
  ArmTypeA 0 eq 
    { /xA2 ArmA AngleA cos mul xA1 add def 
      /yA2 ArmA AngleA sin mul yA1 add def } 
    { ArmTypeA 1 eq {{exch}} {{}} ifelse 
      /Do ED 
      ArmA AngleA XYPos OffsetA AngleA AddOffset 
      yA add /yA2 ED 
      xA add /xA2 ED } ifelse 
} def
%
/GetArmB { 
  ArmTypeB 0 eq 
    { /xB2 ArmB AngleB cos mul xB1 add def 
      /yB2 ArmB AngleB sin mul yB1 add def } 
    { ArmTypeB 1 eq {{exch}} {{}} ifelse 
      /Do ED
      ArmB AngleB XYPos OffsetB AngleB AddOffset 
      yB add /yB2 ED 
      xB add /xB2 ED } ifelse 
} def
%
/InitNC { 
  /b ED /a ED % second and first node
  /NodeSepTypeB ED /NodeSepTypeA ED 
  /NodeSepB ED /NodeSepA ED 
  /OffsetB ED /OffsetA ED 
  tx@NodeDict a known tx@NodeDict b known and dup { 
    /NodeA a load def 
    /NodeB b load def 
    NodeA GetCenter /yA ED /xA ED 
    NodeB GetCenter /yB ED /xB ED } if 
} def
%
/LPutLine { 
  4 copy 
  3 -1 roll sub neg 3 1 roll sub Atan /NAngle ED 
  1 t sub mul 
  3 1 roll 1 t sub mul 
  4 1 roll t mul add /Y ED 
  t mul add /X ED 
} def
%
/LPutLines { 
  mark LPutVar counttomark 2 div 1 sub /n ED 
%  t floor dup n gt 
  t floor dup n ge 		% to allow npos<= hv 2008-08-14
  { pop n 1 sub /t 1 def } { dup t sub neg /t ED } ifelse 
  cvi 2 mul { pop } repeat 
  LPutLine 
  cleartomark 
} def
%
/BezierMidpoint { 
  /y3 ED /x3 ED /y2 ED /x2 ED /y1 ED /x1 ED /y0 ED /x0 ED /t ED 
  /cx x1 x0 sub 3 mul def 
  /cy y1 y0 sub 3 mul def 
  /bx x2 x1 sub 3 mul cx sub def 
  /by y2 y1 sub 3 mul cy sub def 
  /ax x3 x0 sub cx sub bx sub def 
  /ay y3 y0 sub cy sub by sub def 
  ax t 3 exp mul bx t t mul mul add 
  cx t mul add x0 add ay t 3 exp mul 
  by t t mul mul add cy t mul add
  y0 add 3 ay t t mul mul mul 2 
  by t mul mul add cy add 3 ax t t mul mul mul 
  2 bx t mul mul add cx add atan /NAngle ED 
  /Y ED /X ED 
} def
%
/HPosBegin { yB yA ge { /t 1 t sub def } if /Y yB yA sub t mul yA add def
} def
%
/HPosEnd { /X Y yyA sub yyB yyA sub Div xxB xxA sub mul xxA add def
           /NAngle yyB yyA sub xxB xxA sub Atan def 
} def
/HPutLine { HPosBegin /yyA ED /xxA ED /yyB ED /xxB ED HPosEnd  } def
%
/HPutLines { HPosBegin yB yA ge 
  { /check { le } def } { /check { ge } def } ifelse 
  /xxA xA def 
  /yyA yA def 
  mark xB yB LPutVar 
    { dup Y check { exit } { /yyA ED /xxA ED } ifelse } 
  loop 
  /yyB ED /xxB ED cleartomark HPosEnd 
} def
%
/VPosBegin { 
  xB xA lt { /t 1 t sub def } if /X xB xA sub t mul xA add def
} def
%
/VPosEnd { /Y X xxA sub xxB xxA sub Div yyB yyA sub mul yyA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/VPutLine { VPosBegin /yyA ED /xxA ED /yyB ED /xxB ED VPosEnd  } def
/VPutLines { VPosBegin xB xA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { 1 index X check {
exit } { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark
VPosEnd  } def
/HPutCurve { gsave newpath /SaveLPutVar /LPutVar load def LPutVar 8 -2
roll moveto curveto flattenpath /LPutVar [ {} {} {} {} pathforall ] cvx
def grestore exec /LPutVar /SaveLPutVar load def 
} def
%
/NCCoor { 
  /AngleA yB yA sub xB xA sub Atan def 
  /AngleB AngleA 180 add def
  GetEdgeA GetEdgeB 
  /LPutVar [ xB1 yB1 xA1 yA1 ] cvx def 
  /LPutPos { LPutVar LPutLine } def 
  /HPutPos { LPutVar HPutLine } def 
  /VPutPos { LPutVar VPutLine } def 
  LPutVar 
} def
%
/NCLine { 
  NCCoor 
  tx@Dict begin 
  ArrowA CP 4 2 roll 
  ArrowB 
  lineto pop pop
  end 
} def
%
/NCLines { 
  false NArray 
  n 0 eq 
    { NCLine } 
    { 2 copy yA sub exch xA sub Atan /AngleA ED 
      n 2 mul dup index exch index yB sub exch xB sub 
      Atan /AngleB ED 
      GetEdgeA GetEdgeB 
      /LPutVar [ xB1 yB1 n 2 mul 4 add 4 roll xA1 yA1 ] cvx def 
      mark LPutVar 
      tx@Dict begin false Line end 
      /LPutPos { LPutLines } def 
      /HPutPos { HPutLines } def 
      /VPutPos { VPutLines } def 
    } ifelse 
} def
%
/NCCurve { 
  GetEdgeA 
  GetEdgeB 
  xA1 xB1 sub yA1 yB1 sub Pyth 2 div dup 3 -1
roll mul /ArmA ED mul /ArmB ED /ArmTypeA 0 def /ArmTypeB 0 def GetArmA
GetArmB xA2 yA2 xA1 yA1 tx@Dict begin ArrowA end xB2 yB2 xB1 yB1 tx@Dict
begin ArrowB end curveto /LPutVar [ xA1 yA1 xA2 yA2 xB2 yB2 xB1 yB1 ]
cvx def /LPutPos { t LPutVar BezierMidpoint } def /HPutPos { { HPutLines
} HPutCurve } def /VPutPos { { VPutLines } HPutCurve } def } def
%
/NCAngles { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform pop 
  xB2 yB2 mtrx transform exch pop 
  mtrx itransform 
  /y0 ED /x0 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def } def
%
/NCAngle { 
  GetEdgeA GetEdgeB GetArmB 
  /mtrx AngleA matrix rotate def 
  xB2 yB2 mtrx itransform pop xA1 yA1 mtrx itransform exch pop mtrx transform
  /y0 ED /x0 ED 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA1 yA1
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCBar { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def
  xA2 yA2 mtrx itransform pop 
  xB2 yB2 mtrx itransform pop 
  sub dup 0 mtrx transform 
  3 -1 roll 0 gt 
    { /yB2 exch yB2 add def /xB2 exch xB2 add def }
    { /yA2 exch neg yA2 add def /xA2 exch neg xA2 add def } ifelse 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCDiag { 
  /lineAngle ED
  GetEdgeA GetEdgeB GetArmA GetArmB mark
  lineAngle abs 0 gt {
    /xTemp xA2 10 add def
    /yTemp yA2 lineAngle dup sin exch cos div 10 mul add def
    /dY1 yTemp yA2 sub def
    /dX1 xTemp xA2 sub def
    /dY2 yB2 yB1 sub def
    /dX2 xB2 xB1 sub def
    dX1 abs 0.01 lt {
      /m2 dY2 dX2 div def
      /xB2 xA2 def
      /yB2 xA2 xB1 sub m2 mul yB1 add def
    }{
      dX2 abs 0.01 lt {
        /m1 dY1 dX1 div def
        /xB2 xB1 def
        /yB2 xB1 xA2 sub m1 mul yA2 add def
      }{%
        /m1 dY1 dX1 div def
        /m2 dY2 dX2 div def
        /xB2 m1 xA2 mul m2 xB1 mul sub yA2 sub yB1 add m1 m2 sub div def
        /yB2 xB2 xA2 sub m1 mul yA2 add def
      } ifelse
    } ifelse
  } if
  ArmB 0 ne { xB1 yB1 } if
  xB2 yB2 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
%
%  GetEdgeA GetEdgeB GetArmA GetArmB mark 
%  ArmB 0 ne { xB1 yB1 } if
%  xB2 yB2 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end
%  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCDiagg { 
  /lineAngle ED
  GetEdgeA GetArmA 
  lineAngle abs 0 gt 
    { lineAngle }
    { yB yA2 sub xB xA2 sub Atan 180 add } ifelse 
  /AngleB ED
  GetEdgeB mark
  lineAngle abs 0 gt {
    /dY2 yA2 yA1 sub def
    /dX2 xA2 xA1 sub def
    lineAngle abs 90 eq {
      /m2 dY2 dX2 div def
      /yA2 xB xA2 sub m2 mul yA2 add def
      /xA2 xB def
    }{
      /m1 lineAngle dup sin exch cos div def % tan alpha
      dX2 abs 0.01 lt {
        /yA2 xA1 xB sub m1 mul yB add def
        /xA2 xA1 def
      }{%
        /m2 dY2 dX2 div def
        /xA2 m1 xB mul m2 xA2 mul sub yA2 add yB sub m1 m2 sub div def
        /yA2 xA2 xB sub m1 mul yB add def
      } ifelse
    } ifelse
  } if
  xB1 yB1 xA2 yA2
  ArmA 0 ne { xA1 yA1 } if
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def
  /VPutPos { VPutLines } def
%
%  GetEdgeA GetArmA 
%  yB yA2 sub xB xA2 sub Atan 180 add /AngleB ED
%  GetEdgeB 
%  mark 
%  xB1 yB1 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end 
%  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCLoop { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform loopsize add /yA3 ED /xA3 ED 
  /xB3 xB2 yB2 mtrx transform pop def 
  xB3 yA3 mtrx itransform /yB3 ED /xB3 ED 
  xA3 yA3 mtrx itransform /yA3 ED /xA3 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
% DG/SR modification begin - May 9, 1997 - Patch 1
%/NCCircle { 0 0 NodesepA nodeA \tx@GetEdge pop xA sub 2 div dup 2 exp r
%r mul sub abs sqrt atan 2 mul /a ED r AngleA 90 add PtoC yA add exch xA add
%exch 2 copy /LPutVar [ 4 2 roll r AngleA ] cvx def /LPutPos { LPutVar t 360
%mul add dup 5 1 roll 90 sub \tx@PtoC 3 -1 roll add /Y ED add /X ED /NAngle ED
%
/NCCircle { 
  NodeSepA 0 NodeA 0 GetEdge pop 
  2 div dup 2 exp r r mul sub abs sqrt 
  atan 2 mul /a ED 
  r AngleA 90 add PtoC yA add exch xA add 
  exch 2 copy 
  /LPutVar [ 4 2 roll r AngleA ] cvx def 
  /LPutPos { 
    LPutVar t 360 mul add dup 5 1 roll 90 sub PtoC 
    3 -1 roll add 
    /Y ED add /X ED /NAngle ED
% DG/SR modification end
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
  r AngleA 90 sub a add AngleA 270 add a sub 
  tx@Dict begin 
  /angleB ED /angleA ED /r ED 
  /c 57.2957 r Div def 
  /y ED /x ED 
} def
%
/NCBox { 
  /d ED /h ED 
  /AngleB yB yA sub xB xA sub Atan def 
  /AngleA AngleB 180 add def 
  GetEdgeA GetEdgeB 
  /dx d AngleB sin mul def 
  /dy d AngleB cos mul neg def 
  /hx h AngleB sin mul neg def 
  /hy h AngleB cos mul def 
  /LPutVar [ 
    xA1 hx add yA1 hy add xB1 hx add yB1 hy add 
    xB1 dx add yB1 dy add xA1 dx add yA1 dy add ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { xB yB xA yA LPutLine } def 
  /VPutPos { HPutPos } def 
  mark 
  LPutVar tx@Dict begin false Polygon end 
} def
%
/NCArcBox { 
  /l ED neg /d ED /h ED /a ED 
  /AngleA yB yA sub xB xA sub Atan def 
  /AngleB AngleA 180 add def 
  /tA AngleA a sub 90 add def 
  /tB tA a 2 mul add def 
  /r xB xA sub tA cos tB cos sub Div dup 0 eq { pop 1 } if def
  /x0 xA r tA cos mul add def 
  /y0 yA r tA sin mul add def 
  /c 57.2958 r div def 
  /AngleA AngleA a sub 180 add def 
  /AngleB AngleB a add 180 add def
  GetEdgeA GetEdgeB 
  /AngleA tA 180 add yA yA1 sub xA xA1 sub Pyth c mul sub def 
  /AngleB tB 180 add yB yB1 sub xB xB1 sub Pyth c mul add def 
  l 0 eq { 
    x0 y0 r h add AngleA AngleB arc x0 y0 r d add AngleB AngleA arcn 
  }{ 
    x0 y0 translate 
    /tA AngleA l c mul add def 
    /tB AngleB l c mul sub def
    0 0 r h add tA tB arc r h add 
    AngleB PtoC r d add 
    AngleB PtoC 2 copy 
    6 2 roll l arcto 4 { pop } repeat 
    r d add tB PtoC l arcto 4 { pop } repeat 
    0 0 r d add tB tA arcn r d add 
    AngleA PtoC r h add 
    AngleA PtoC 2 copy 6 2 roll 
    l arcto 4 { pop } repeat 
    r h add tA PtoC l arcto 4 { pop } repeat 
  } ifelse 
  closepath 
  /LPutVar [ x0 y0 r AngleA AngleB h d ] cvx def 
  /LPutPos { 
    LPutVar /d ED /h ED 
    /AngleB ED /AngleA ED 
    /r ED /y0 ED /x0 ED 
    t 1 le { 
      r h add AngleA 1 t sub mul AngleB t mul add dup 90 add /NAngle ED PtoC 
    }{t 2 lt { 
        /NAngle AngleB 180 add def r 2 t sub 
        h mul t 1 sub d mul add add AngleB PtoC 
      }{ 
        t 3 lt { 
          r d add AngleB 3 t sub mul AngleA 2 t sub
          mul add dup 90 sub /NAngle ED PtoC 
        }{ 
          /NAngle AngleA 180 add def 
          r 4 t sub d mul t 3 sub h mul add add AngleA PtoC 
        } ifelse 
      } ifelse 
    } ifelse
    y0 add /Y ED x0 add /X ED 
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
} def
%
/Tfan { /AngleA yB yA sub xB xA sub Atan def GetEdgeA w xA1 xB sub yA1 yB
sub Pyth Pyth w Div CLW 2 div mul 2 div dup AngleA sin mul yA1 add /yA1
ED AngleA cos mul xA1 add /xA1 ED /LPutVar [ xA1 yA1 m { xB w add yB xB
w sub yB } { xB yB w sub xB yB w add } ifelse xA1 yA1 ] cvx def /LPutPos
{ LPutLines } def /VPutPos@ { LPutVar flag { 8 4 roll pop pop pop pop }
{ pop pop pop pop 4 2 roll } ifelse } def /VPutPos { VPutPos@ VPutLine }
def /HPutPos { VPutPos@ HPutLine } def mark LPutVar tx@Dict begin
/ArrowA { moveto } def /ArrowB { } def false Line closepath end } def
%
/LPutCoor { 
  NAngle 
  tx@Dict begin /NAngle ED end 
  gsave 
  CM STV 
  CP Y sub neg exch X sub neg exch moveto 
  setmatrix CP 
  grestore 
} def
%
/LPut { 
  tx@NodeDict /LPutPos known 
    { LPutPos } { CP /Y ED /X ED /NAngle 0 def } ifelse 
  LPutCoor  
} def
%
/HPutAdjust { 
  Sin Cos mul 0 eq 
    { 0 } 
    { d Cos mul Sin div flag not { neg } if 
      h Cos mul Sin div flag { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { r add neg }{ l add } ifelse 
  X add /X ED 
} def
%
/VPutAdjust { 
  Sin Cos mul 
  0 eq 
    { 0 }
    { l Sin mul Cos div flag { neg } if
      r Sin mul Cos div flag not { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { d add } { h add neg } ifelse 
  Y add /Y ED 
} def
%
%
end
%
% END pst-node.pro

%% $Id: pst-3d.pro 247 2010-01-04 22:45:42Z herbert $
% PostScript prologue for pst-3d.tex.
% Version 0.01, 2010/01/01 
%
/tx@3Ddict 300 dict def 
tx@3Ddict begin
%
/SetMatrixThreeD {
  dup sin /e ED cos /f ED
  /p3 ED /p2 ED /p1 ED
  p1 0 eq
  { /a 0 def /b p2 0 le { 1 } { -1 } ifelse def
    p3 p2 abs
  }
  { p2 0 eq
    { /a p1 0 lt { -1 } { 1 } ifelse def /b 0 def
      p3 p1 abs
    }
    { p1 dup mul p2 dup mul add sqrt dup
      p1 exch div /a ED
      p2 exch div neg /b ED
      p3 p1 a div
    }
    ifelse
  }
  ifelse
  atan dup sin /c ED cos /d ED
  /Matrix3D
  [
    b f mul c a mul e mul sub
    a f mul c b mul e mul add
    d e mul
    b e mul neg c a mul f mul sub
    a e mul neg c b mul f mul add
    d f mul
  ] def
} def
%
/ProjThreeD {
  /z ED /y ED /x ED
  Matrix3D aload pop
  z mul exch y mul add exch x mul add
  4 1 roll
  z mul exch y mul add exch x mul add
  exch
} def
%
/SetMatrixEmbed {
  SetMatrixThreeD
  Matrix3D aload pop
  /z3 ED /z2 ED /z1 ED /x3 ED /x2 ED /x1 ED
  SetMatrixThreeD
  [
  Matrix3D aload pop
  z3 mul exch z2 mul add exch z1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  Matrix3D aload pop
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  x3 mul exch x2 mul add exch x1 mul add
  3 -1 roll 3 -1 roll 4 -1 roll 8 -3 roll 3 copy
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  ]
  concat
} def
%
/TMSave {
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
} def
%
/TMRestore { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/TMChange {
  TMSave
  /cp [ currentpoint ] cvx def % ??? Check this later.
  CM
  CP T STV
  CM matrix invertmatrix    % Inv(M')
  matrix concatmatrix       % M Inv(M')
  exch exec
  concat cp moveto
} def
%
end % of tx@3Ddict
%%
%% End of file `pst-3d.pro'.

%                           -*- Mode: Postscript -*-
% pst-math.pro --- PostScript header file pst-math.pro
%
% Author          : Christophe JORSSEN 
% Author          : Herbert Vo <hvoss@tug.org>
% Last Mod        : $Date: 2014/07/30 $
% Version         : 0.63 $
%
/PI 3.14159265359 def
/ENeperian 2.71828182846 def
%
/DegToRad {PI mul 180 div} bind def
/RadToDeg {180 mul PI div} bind def
%
/COS {RadToDeg cos} bind def
/SIN {RadToDeg sin} bind def
/TAN {dup SIN exch COS Div} bind def
/tan {dup sin exch cos Div} bind def
/ATAN {neg -1 atan 180 sub DegToRad} bind def
/ACOS {dup dup mul neg 1 add sqrt exch atan DegToRad} bind def
/acos {dup dup mul neg 1 add sqrt exch atan} bind def
/ASEC {1 exch Div ACOS} bind def
/ASIN {neg dup dup mul neg 1 add sqrt neg atan 180 sub DegToRad} bind def
/asin {neg dup dup mul neg 1 add sqrt neg atan 180 sub} bind def
/ACSC {1 exch Div ASIN} bind def
%
/EXP {ENeperian exch exp} bind def
%
/COSH {dup EXP exch neg EXP add 2 div} bind def
/SINH {dup EXP exch neg EXP sub 2 div} bind def
/TANH {dup SINH exch COSH div} bind def
/ACOSH {dup dup mul 1 sub sqrt add ln} bind def
/ASINH {dup dup mul 1 add sqrt add ln} bind def
/ATANH {dup 1 add exch neg 1 add Div ln 2 div} bind def
%
%/SINC {dup SIN exch Div} bind def
/SINC { dup 0 eq { pop 1 } { dup SIN exch div } ifelse } bind def

/GAUSS {dup mul 2 mul dup 4 -2 roll sub dup mul exch div neg EXP exch PI mul sqrt div} bind def
%
/GAMMA { 2 dict begin				% hv 2007-08-30
  /z exch def
  1.000000000190015				% p(0)
  0 1 5 {					% on stack is 0 1 2 3 4 5 
    dup 					% n-1 n-1
    [ 76.18009172947146 
     -86.50532032941677 
      24.0140982483091 
      -1.231739572450155
       0.1208650973866179E-2 
      -0.5395239384953E-5      ] exch get exch 	% p(n) n-1
      1 add z add div			     	% p(n)/(z+n)
      add					% build the sum
    } for
    Pi 2 mul sqrt z div mul
    z 5.5 add z 0.5 add exp mul ENeperian z 5.5 add neg exp mul 
  end } bind def
%    
/GAMMALN {dup dup dup 5.5 add dup ln 3 -1 roll .5 add mul sub neg 1.000000000190015
    0 1 5 {
    [76.18009172947146 -86.50532032941677 24.0140982483091 -1.231739572450155
    .1208650973866179E-2 -.5395239384953E-5 2.5066282746310005] exch get
    4 -1 roll 1 add dup 5 1 roll div add} for
    4 -1 roll div 2.5066282746310005 mul ln add exch pop} bind def
/BETA {2 copy add GAMMALN neg exch GAMMALN 3 -1 roll GAMMALN EXP} bind def
%
/HORNER {aload length
    dup 2 add -1 roll
    exch 1 sub {
        dup 4 1 roll
        mul add exch
    } repeat
    pop
} bind def
%
/BESSEL_J0 {dup abs 8 lt {
    dup mul dup [57568490574 -13362590354 651619640.7 -11214424.18 77392.33017 -184.9052456] HORNER
    exch [57568490411 1029532985 9494680.718 59272.64853 267.8532712 1] HORNER
    Div}
    {abs dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup 
    [1 -1.098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index COS mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul} 
    ifelse} bind def
%
/BESSEL_Y0 {dup 8 lt {
    dup dup mul dup [-2957821389 7062834065 -512359803.6 10879881.29 -86327.92757 228.4622733] HORNER
    exch [40076544269 745249964.8 7189466.438 47447.26470 226.1030244 1] HORNER
    Div exch dup ln exch BESSEL_J0 .636619772 mul mul add}
    {dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup 
    [1 -.1098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index SIN mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul} 
    ifelse} bind def
%
/BESSEL_J1 {dup abs 8 lt {
    dup dup mul dup 3 -2 roll [72362614232 -7895059235 242396853.1 -2972611.439 15704.48260 -30.16036606] HORNER mul
    exch [144725228442 2300535178 18583304.74 99447.43394 376.9991397 1] HORNER
    Div}
    {dup abs dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup 
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index COS mul
    exch [.04687499995 6.2002690873E-3 .8449199096E-5 -.88228987E-6 .105787412E-6] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul exch dup abs Div mul} 
    ifelse} bind def
%
/BESSEL_Y1 {dup 8 lt {
    dup dup dup mul dup [-.4900604943E13 .1275274390E13 -.5153428139E11 .7349264551E9 -.4237922726E7 .8511937935E4] HORNER
    exch [.2499580570E14 .4244419664E12 .3733650367E10 .2245904002E8 .1020426050E6 .3549632885E3 1] HORNER
    Div mul exch dup dup ln exch BESSEL_J1 mul exch 1 exch div sub .636619772 mul add}
    {dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup 
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index SIN mul
    exch [.04687499995 -.2002690873E-3 .8449199096E-5 6.88228987E-6 .105787412E-6] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul} 
    ifelse} bind def
%
% En cours...
/BESSEL_Yn {dup 0 eq {pop BESSEL_Y0}{dup 1 eq {pop BESSEL_Y1}{
    exch dup BESSEL_Y0 exch dup BESSEL_Y1 exch 2 exch Div {
        mul 3 -1 roll mul 2 index sub pstack} for
    } ifelse } ifelse } bind def
%
/SIMPSON { 1 dict begin  %% on stack a b var f ierr  Dominik Rodriguez
  3 index 5 index sub                                % compute h
  1                                                  % a b var f ierr h n
  4 index 7 index def 3 index exec                   % a b var f ierr h n f(a)
  5 index 7 index def 4 index exec add               % a b var f ierr h n f(a)+f(b)
  5 index 8 index 4 index 2 div add def 4 index exec % a b var f ierr h n f(a)+f(b) f(a+h/2)
  exch 1 index 4 mul add 0  % a b var f ierr h n old=f(a+h/2) Estim=f(a)+f(b)+4f(a+h/2) NbLoop
    {                                                % a b var f ierr h n old Estim NbLoop
      5 -1 roll 2 div dup 6 1 roll              % h<-h/2
      5 -1 roll 2 mul 5 1 roll                  % n<-2n
                                                % a b var f ierr h n old Estim NbLoop h
      2 div 10 index add 0                      % a b var f ierr h n old Estim NbLoop a+h/2 Cumul
      5 index { 
        1 index 10 index exch def 8 index exec add exch 6 index add exch 
      } repeat                                  % a b var f ierr h n old Estim NbLoop a+nh/2 Cumul
      exch pop                                  % a b var f ierr h n old Estim NbLoop New
      2 index 1 index 4 mul 6 -1 roll 2 mul sub sub % a b var f ierr h n Estim NbLoop New Diff
      4 -1 roll 2 mul 1 index sub 4 1 roll          % a b var f ierr h n Estim NbLoop New Diff
      exch 4 1 roll                             % a b var f ierr h n old Estim NbLoop Diff
      5 index 6 div mul abs 6 index lt { exit } if
      1 add dup 9 eq { exit } if
  } loop                                        % a b var f ierr h n old Estim NbLoop
  exch 5 -1 roll 6 div mul mark 10 2 roll cleartomark
end 
} def
% ------------------------------------ math stuff ----------------------------------
%
% Matrix A in arrays of rows A[[row1][row2]...]
% with [row1]=[a11 a12 ... b1]
% returns on stack solution vector X=[x1 x2 ... xn]
/SolveLinEqSystem { 				% on stack matrix M=[A,b] (A*x=b)
  10 dict begin					% hold all ocal
    /A exch def
    /Rows A length def         			% Rows = number of rows
    /Cols A 0 get length def   			% Cols = number of columns
    /Index [ 0 1 Rows 1 sub { } for ] def	% Index = [0 1 2 ... Rows-1]
    /col 0 def
    /row  0 def
    /PR Rows array def 				% PR[c] = pivot row for row row
  { 						% starts the loop, find pivot entry in row r
    col Cols ge row  Rows ge or { exit } if	% col < Cols and row < Rows else exit
    /pRow row def  				% pRow = pivot row		
    /max A row  get col get abs def		% get A[row[col]], first A[0,0] 
    row 1 add 1 Rows 1 sub { 			% starts for loop 1 1 Rows-1
      /j exch def				% index counter
      /x A j get col get abs def		% get A[j[r]]
      x max gt {				% x>max, then save position
        /pRow j def
        /max x def
      } if
    } for					% now we have the row with biggest A[0,1]
						% with pRow = the pivot row
    max 0 gt {					% swap entries pRow and row  in i 
      /tmp Index row  get def
      Index row  Index pRow get put
      Index pRow tmp put			% and columns pRow and row  in A
      /tmp A row get def
      A row  A pRow get put
      A pRow tmp put   				% pivot
      /row0  A row  get def 			% the pivoting row
      /p0 row0  col get def 			% the pivot value
      row 1 add 1 Rows 1 sub { 			% start for loop
        /j exch def
        /c1 A j get def
        /p c1 col get p0 div def
        c1 col p put				% subtract (p1/p0)*row[i] from row[j]
        col 1 add 1 Cols 1 sub {		% start for loop
          /i exch def
          c1 dup i exch 			% c1 i c1
          i get row0 i get p mul sub put
        } for
      } for
      PR row col put
      /col col 1 add def
      /row row 1 add def
    }{						% all zero entries
      /row row 1 add def			% continue loop with same row
    } ifelse
  } loop
  /X A def					% solution vector
  A Rows 1 sub get dup
  Cols 1 sub get exch
  Cols 2 sub get div
  X Rows 1 sub 3 -1 roll put  			% X[n]
  Rows 2 sub -1 0 {				% for loop to calculate X[i]
    /xi exch def				% current index
    A xi get 					% i-th row
    /Axi exch def
    /sum 0 def
    Cols 2 sub -1 xi 1 add { 
      /n exch def
      /sum sum Axi n get X n get mul add def 
    } for
    Axi Cols 1 sub get 				% b=Axi[Cols-1]
    sum sub 					% b-sum
    Axi xi get div				% b-sum / Axi[xi]
    X xi 3 -1 roll put  			% X[xi]
  } for
  X
  end 
} def
%
/c@_0 2.515517 def 
/c@_1 0.802853 def 
/c@_2 0.010328 def 
/d@_1 1.432788 def 
/d@_2 0.189269 def 
/d@_3 0.001308 def 
/norminv {
  5 dict begin
  neg 1 add 1 exch div ln 2 mul sqrt 
  /t exch def 
  /t2 t dup mul def 
  /t3 t2 t mul def 
  c@_0 c@_1 t mul add c@_2 t2 mul add 1 d@_1 t mul add 
  d@_2 t2 mul add d@_3 t3 mul add div neg t add 
  end
} def 
%end{norminv Michael Sharpe}
%
%
% END pst-math.pro

%% $Id: pstricks-add.pro 37 2014-07-22 13:52:12Z herbert $
%%
% PostScript prologue for pstricks-add.tex.
%
% Version 0.23, 2009/12/17 
%
/tx@addDict 410 dict def tx@addDict begin
%%
realtime srand % set random generator
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/GTriangle {
  gsave
  /mtrx CM def
  /colorA ED /colorB ED /colorC ED 	% save the colors
  /yA ED /xA ED               		% save the origin
  xA yA translate
  rotate       		        	% \psk@gangle
  /yB ED /xB ED /yC ED /xC ED   	% save other coordinates
  /ds [                % save data in a array
     0 0 0 colorA aload pop     	% fd x y xr xg xb
     0 xB xA sub yB yA sub colorB aload pop
     0 xC xA sub yC yA sub colorC aload pop
%     1 xC xB add yB colorA aload pop  	% for use with 4 points ABCD
  ] def
  newpath
  <<
  /ShadingType 4           % single Gouraud
  /ColorSpace [ /DeviceRGB ]
  /DataSource ds
  >> 
  shfill
  closepath
  mtrx
  setmatrix grestore} def
%
/RGBtoCMYK {    % on stack r g b -> C M Y K
  3 dict begin
  /Blue ED /Green ED /Red ED
  1 Red sub     % Cyan
  1 Green sub   % Magenta
  1 Blue sub    % Yellow
  0   		% Black  
  end
} def
%
/CMYKtoGRAY { % on stack c m y k -> gray
  exch 0.11 mul add
  exch 0.59 mul add
  exch 0.3 mul add
  dup 1 gt { pop 1 }  if 
  neg 1 add 
} def
%
/RGBtoGRAY { % on stack r g b -> gray
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
} def
%
/HSBtoGRAY { 
  6 dict begin
  /b exch def 
  /s exch def 6 mul dup cvi dup 
  /i exch def sub 
  /f exch def
  /F [[0 1 f sub 1][f 0 1][1 0 1 f sub][1 f 0][1 f sub 1 0][0 1 f][0 1 1]] def
  F i get { s mul neg 1 add b mul} forall
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
  end
} def
%
%% convertisseur longueur d'onde ->R,G,B       Manuel Luque
%% lambda max=780 nanometres
%% lambda min=380 nanometres
%% adaptation de :
%% http://www.physics.sfasu.edu/astro/color.html
%% www.efg2.com/lab
%
/Gamma 0.8 def
/calculateRGB {
  lambda 379 le {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 781 ge {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 380 ge {lambda 439 le {
    /R {lambda 440 sub neg 440 380 sub div} def
    /Red R factor mul Gamma exp def
    /G 0 def
    /Green G factor mul Gamma exp def
    /B 1 def
    /Blue B factor mul Gamma exp def} if
  } if
  lambda 440 ge { lambda 489 le {
    /G {lambda 440 sub 490 440 sub div} def
    /Green G factor mul Gamma exp def
    /R 0 def /Red 0 def
    /B 1 def
    /Blue B factor mul Gamma exp def } if
  } if
  lambda 490 ge {lambda 509 le {
    /B {lambda 510 sub neg 510 490 sub div} def
    /Blue B factor mul Gamma exp def
    /R 0 def /Red 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 510 ge {lambda 579 le {
    /R {lambda 510 sub 580 510 sub div } def
    /Red R factor mul Gamma exp def
    /Blue 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 580 ge {lambda 644 le {
    /G {lambda 645 sub neg 645 580 sub div } def
    /Green G factor mul Gamma exp def
    /Blue 0 def
    /R 1 def
    /Red R factor mul Gamma exp def } if
  } if
  lambda 645 ge { lambda 780 le {
    /Red 1 factor mul Gamma exp def
    /Blue 0 def
    /Green 0 def } if
  } if
} def
%
/factor {
  lambda 380 ge {lambda 419 le { 0.3 0.7 lambda 380 sub mul 420 380 sub div add} if } if
  lambda 420 ge {lambda 700 le { 1 } if } if
  lambda 701 ge {lambda 780 le { 0.3 0.7 780 lambda sub mul 780 700 sub div add} if } if
} def
%
/wavelengthToRGB { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
} def %  now the colors are saved in Red Green Blue
%
/wavelengthToGRAY { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
  Red Green Blue RGBtoGRAY
} def %  now the gray color is on the stack
%
/wavelengthToCMYK { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  gsave
  calculateRGB Red Green Blue RGBtoCMYK 
  /Black ED /Yellow ED /Magenta ED /Cyan ED
  grestore
} def %  now the colors are saved in Cyan Magenta Yellow Black
%
/axfill {
    8 dict begin
    /xw exch def /nl exch def
    /C1 exch def /y1 exch def/x1 exch def
    /C0 exch def /y0 exch def/x0 exch def
    <<  /ShadingType 2
        /ColorSpace /DeviceRGB
        /Coords [ x0 y0 x1 y1 ]
        /EmulatorHints [ xw 2 div dup ]
        /Function <<
            /FunctionType 2
            /Domain [0 1]
            /C0 C0
            /C1 C1
            /N      1
        >>
    >> shfill
    end
} bind def
%
%/amplHand {.8} def 
%/dtHand 2 def
/varHand { rand sin amplHand mul add } def
/MovetoByHand { moveto } def 
%/MovetoByHand { /y0 ED /x0 ED x0 y0 moveto } def 
/LinetoByHand { 4 dict begin
  /y1 ED /x1 ED 
  currentpoint /y0 ED /x0 ED
  x0 x1 sub dup mul y0 y1 sub dup mul add sqrt /dEnd ED
  0 dtHand dEnd { dup
    x1 x0 sub mul dEnd div x0 add varHand exch  
    y1 y0 sub mul dEnd div y0 add varHand lineto
  } for
%  /x0 x1 def /y0 y1 def
  end
} def  
%
end
%
% END pstricks-add.pro

%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]FontType 0
ne{/Metrics exch def dict begin Encoding{exch dup type/integertype ne{
pop pop 1 sub dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get
div def}ifelse}forall Metrics/Metrics currentdict end def}{{1 index type
/nametype eq{exit}if exch pop}loop}ifelse[2 index currentdict end
definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{dup
sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1 roll
mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def dup[
exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}if}
forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}def
end

%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/@beginspecial{SDict begin/SpecialSave save N gsave
normalscale currentpoint TR @SpecialDefaults count/ocount X/dcount
countdictstack N}N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto
0 vs rlineto hs neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale
ang rotate rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}
ifelse scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale
llx neg lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly
lineto urx ury lineto llx ury lineto closepath clip}if/showpage{}N
/erasepage{}N/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{
count ocount sub{pop}repeat countdictstack dcount sub{end}repeat
grestore SpecialSave restore end}N/@defspecial{SDict begin}N
/@fedspecial{end}B/li{lineto}B/rl{rlineto}B/rc{rcurveto}B/np{/SaveX
currentpoint/SaveY X N 1 setlinecap newpath}N/st{stroke SaveX SaveY
moveto}N/fil{fill SaveX SaveY moveto}N/ellipse{/endangle X/startangle X
/yrad X/xrad X/savematrix matrix currentmatrix N TR xrad yrad scale 0 0
1 startangle endangle arc savematrix setmatrix}N end

%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

% Part of the hfbright font family by Harald Harders, h.harders@tu-bs.de
% Generated by PfaEdit 1.0 (http://pfaedit.sf.net/)
FontDirectory/HFBRMI10 known{/HFBRMI10 findfont dup/UniqueID known{dup
/UniqueID get 4214389 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
11 dict begin
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
/FontName /HFBRMI10 def
/FontBBox [-108 -222 995 750 ]readonly def
/PaintType 0 def
/FontInfo 9 dict dup begin
/version (0.6) readonly def
/Notice (Part of the hfbright font family by Harald Harders, h.harders@tu-bs.de) readonly def
/FullName (Computer Modern Bright Math Slanted) readonly def
/FamilyName (Computer Modern Bright) readonly def
/Weight (Regular) readonly def
/ItalicAngle -12 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 80 /P put
dup 83 /S put
dup 88 /X put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CE33C33655F6FF751F340A8D6C01E3
2E02C24E186BA91B34A1F538959D4450CB683EAE5B034D030186901B458D3777
6B3942BD2E07121385120248891AEC2EB33C4E3A0CF00828D0F130C31A918C18
979FE94379C648EF21ABF659253E43CD1253866F157F1DF85AE7E8714F061B1E
ABA3AD094FE8D6293916FA82EE4F486C7E513A06D4C9BE44306A8287970B4ABF
B6D1F9274A5A0BB6ECF713ADBD1260D5D6C4420D357FD486470A74B2F0621B59
A9373ABECDBF32FA68AC06351EB3A0C388F7EDE3D9D355D9933DBEDDB5162DB2
E065C95E6C199FBBABDB5E3C86498B8A2FE34B3617A9C822EE3C206791F723D3
0FA03647B20FBD0D378A55534399BC4BEC29FA576B802D7DC4B3B4E912F30B6D
0C18498C6551CF3E11303E1A6F632D10DA65C085A8FF051316C073571B4CE69D
D554863AC47907AC2BE34DE4203C8A78CBA2A739507E02D313E9A7F89EAE910F
204C63CCA017B73E158669002913003EABB317FB508B2D85A316BE8C707249B5
FDD5B61C1906445E2B04C6896A8E764A825A75424F14E0CD2BA99AC4746E8E0D
F4C4C682F7A0900A2218135DE5E58CA35D1ACB83255F683AAAEF8092CB082A8C
B0D779673F065D7408FDA0804E12BA4729806B39E930A9FF2280D603F9F2EF10
67461193BF703BB5383FFD536F67E20F0A88A204DC683CBE272E7E8489AC8866
30624DC40BE31A47B8AB64840014D5A9F629CABF603B62268885D2161433636E
DE38867D622F58F1DB8CD8B51B88E15F16C6BDF163E66F35C63BCA841D5B489B
6BA7886DE7EC684773BDA0F1AD024A3C82EF259B6D15D71AF7ED9597EC5F4DD5
84489A8B5158381E30DC8ABD5BE39B59C1A5ED488297CA2191BC3437F31CA754
B0DB2112129FFD863EDC2160A80F7D4D943929AB612350F7BF8AE375F111ED7A
9833EC6280F58FC4EA0FEEF49F3B4C15BE9C4712AE4DD13736DFCD0F682D7D32
4F135865A9D0ECD664C6B6B2941B7B85C79DBC210002F76CF6F57AB7D695F17E
1EEB970BCFD0FC394C016EE3E1241018F7ECFEF9F9133E7D3F813F9D8EF25173
41CD5027B799617212EBFA51F6D1291B357B9EE787941BA6D88502E7F25015E5
59877D7052E6F04C062050C9350C78BE68FC3310AB866F6BAD780CBAE845CE86
E0DEC7C0346062DDDE4CF5FC2E46BF916DB10AD9D856447F138F35B9E765834F
FEE3B4A273720A6DEFC528C6BCE8453833E2C176ECF1F0BF1B766B98D882FDC9
79CFAEFDF8D608E2327A19ACC0A9034B600411DB1C1CECFBB3D358C99B87F2C1
66F222CEF2E056AA29A1495379A0716AEF2EDD9C94940C02D20A43E1C7278B67
1681ECE3F220A7CCD7A61F7D638275E0A1C9709BDA8EFC357C6B67EAAACFD6F6
FC503307CF61B15C126262A5CD3EEC6A4B47B8E870B048FB96EAA43DEB2447E4
C2DC9A1E87DA5FF96B15296257FD791D642DFC937F6CEEE01B3B64A3F732908D
553C494E1ACA34EED4E2A18B8DEADE26549988D98A071007FD60A8CEA754DD5D
1CF9D19F956B192C593225B5186109D3E6636E87BA6F24EFEACD1F06A29DB1D1
F4DE4C0AA6781D61C4B98BB30F3047600AE9A238DAF7B6693BBD4CF6D8B6DC1C
56D854BD6FC9ABC29DE904710FB57AE2D3D37E6DE597DF96964042653B056895
0B5D02186B019BF08B8970AFFE725EA77032B9E9125E89A42E94B34B777BD66C
EE3314D4E720A073D85A7744F611F58EF39B08CB435164B147B5D8C76C232F38
AD98588905BA2ED95D450CF65DCEFB3614AC09EB2F118DB4528BE35F52CE59DD
F9FDE381057DEE71419F92E03B83E56C014B6B9A911513AF43380B81D1135B98
BFB97EBF9402FA6967D7DE9369B0692374CADA1F7A810A9D9C5D338D30ABC2B0
16D41B129C722678C54F83C0A679E3FC4B635A1272241BB1A2AECD349D90E7EA
35BC2FE21DF1C2285DA617FBC8988C00C413FADA83672E2D025FD98D3EA9EF3D
3607B7F8BCE6E3C90D7F05398B66ED0AB9CB898D41A707D5F093C49115196746
DA3FBD606898041893DC989777B20975C01E14524F1D17D4AB7DC47CC7DAF3F8
4240C9C118F13C8629046599894F3A4F4029A42A924EB7311588CB06AC8B4D15
2AE6C98EE7D3217350EC9C221291BB4A3DC7AFF5534F2BDA9F17CAEB0F2E2DE9
397CAE4D099A2A45A265C1878E3B66D1D8F2AFD2F43433E23379654245D3D447
E4CA328F1BA7B183C2B8080C54041471BD50D87AE182F1A23C752BB1D241D5DE
D04964B2B851ADE41385F136141D968262CF4DFECA20C869C409E18196B50473
579AD4E6314016337C70AF58A0406DC912689D867F3E7F11985B3FC6C7008725
17A0DB18FD08173F57C9D09B2D3E46C963A95E4C6B0A4D4C5F3122593EA3DE1C
D2AE6693C7D4554882B6C7FA5C910E3C1DD5378EEA45326D211E0E0361149A4A
0CD64CBEDBD6E92D0FC5605CE5498C607810694E0F8C52760E7159ECC1D2AE32
91689119A4B330B2EE9E525101BDD58972A870459125103D25369DA36E884C44
BE8B4BA1C8A1C94F1E6AFCC4A89445F753F25A0CE8FA4FECAB9A050E0DB4DE2C
F5635327E3D19FC89FF70D5163FDEE0D44DEB5B2A3944AC976F7065741B38B3C
39C3979DEB1FA2835657F43F2C256663D87ACEB3501304B9FD91741B6C5682BB
0E8744E070F0A2EA93800D21DA8926CEE57E277EEA7EAD22F0391B94DAFF627E
7E5EC9FC3BB9FCF3ABFDE912A79ED5996C6DEC012B89C2FDF1B829956786C167
FDDDAC20FC72BC0D18E91599BF746CB88ADDAECC286BB17FA8737438370F000D
DF70A6ED38B43A12E510B8D6A1DB5F1CBBD4CAC8B79FC51FAD48B0E2F94DBA82
03E8F573CB5874C9E0ABEE3FE2EF8B051A00491CF8ACA729587DEE21D91292C7
8DCFCC858892DC1A92EACA0B64355D0B52625574FD65E81ABEB5EFDC731B1441
82526AB15C78C3F7FDBCAE79784E438A2B3182547AF16B1B07A6990A66535999
74D954A0C45D957A8C8FF88C6299440E4A8B0BEDFD9DA780738429C0437EAEC5
1106DE8F93B584C085C1FA2AD48F97EC082FF299B22B6C39C194971A13137903
AB3BD96FA3B67708220F561303A446D252B1B25CBC135F011CE1A10F7553F10F
FCDD9936396ACF9B0595340612476C5C437ABF14EAE55C0AF4FE8C2B95131D9F
8434DEA9DA007F0FEA496B1D9C7C52CA038433238110D7A78597090FEBB1B706
A8B53FA6BBB25C0F8CE8E8EDCE6D6CE4E56581A61B190FC65B46A9C7E729B9F0
39C1B8C0EF37E3FD4C096B36D7C1471D5651DAAFB709B49B125795EC05DF5398
3F2610C7A35BA9F21078DCE2C2AAD3A25FDB8836ED743E515A1C6C1541CCD60D
FC3DB292245623C531EB82E03F269ED8720C2614CA1EF5DDCB9A9298F809B940
01C4167D69DA919251752F898E6D493888764FB7DAD6B7DD35FE64AA4DF29773
7FA1B280AEF0D1EE9186410E7F427A4936611D71AE0D7397F3EB892BBC3D246C
4E94154B2016425B1A7A3C34FC55B53B5E705B5A5D12548C23BB017E5B3F40D4
C99E1F4FF6D4AAB704BA1E10F810E91E97E8562A4F35C666090A9E59E2FB9127
E1ED2C6593E2B865236ECE1524E8FB1BB4AF3DBA68CABD13DD69ECD0AF6DA92F
239FFA866E63D1878FD8F057AA0ADB9341AE7F1107DE06FD285828A999D95B80
AC01A5CEB1671DEF707D4486DFB2402F62706AD99CD72285CC8F5E95D0F34196
9192AE8B48F25DBC6531655A7045D6D7D355279D9319CC3BADE5557F9D37DFA0
456193E06078CBB61C022B312CA2B3D74DB563458CC6412EF9C5B8C4D285D0BF
02A2A898D38AF64FE37782D7F0E7CC94AD9E9F3434B4F69494ECE226BCA88380
9BC480C901FCD7089041F5C5DEDB8E188529F6DC7A9C923E752BA94909AAFD76
077C0401388FDEF9CF9B0B34BDB181D82A94DF97C194D2302CC47BF968CB1F6D
476765DD1CD2FBB994EC139664E9E278EC58A25FD4BCE68C8D1BA58F1255C59A
D6D59CDA594FCB68C8C5127C4618F4BEC2FAB5114636766D888A80D205E78F88
2D02F2CBA17EDE995CDE74E48EA55C839864A5D45B465CA331D95586930CA2E2
71A5C12DA076503B8198F337A5761A4ED280F37840128111881B35C2C7D6509B
2B749F1409EEB6DA20C70A57129401EC59C99CD51EF50448E8F5D34353C29A0A
37B7E891FCA023EF18CDB84BB5603015772B4C2F1C40944D74403778839F2E5B
EAC028CBBAF92100102140AAA9E97913839EB63B2AE86D9E39F7A45CDCE00565
27C177015E0BEC10FFD659CFC1E95FD36CDE39709B2DD2DAD37A00E505809A5C
E9D124C7604DBBDA4AD77AF37A4C38026C0ADD6F38C9BD6989E8A8C313A7DE26
FC525AB4B1E597299235D3A7EE768F2B480A1C5EC1FDD19830EA5382670CC166
BA0EA444025898A5091070E9358A4B5BEB88E23A18EB30BDE3AD1979667B77C3
36C55C42B7B4599137559B2089AA01090C393808B08ACC4C48442B68B5666B68
53ADDE30FCB28A904ECD3E183C3D1F25DE193F09ABFB21B2744C63EFC978ECA8
C4E3BE979D2B2633EF65B815F9ED5EC1981A4C83D013EAA8FC5A649003996D3B
EEFF79954671C6F4524293FC420941DC87E95DD4E370F678F8A7492C70E418F8
2F032745494F1D61F8C0BECBA74CC30193929D4F5141B0D6655A0CE9AD64BA34
09E0AD2E0E10FE45639852F9148A7632F3512EFA7C022C4500495C315D0C7085
A4D489C273001B8DDD2A7A5FD54E47497D59CB91F42FA2832ED3DD9554A76CF7
7068C00D32B65CDD3476133D5AF921FF8724EDB8A2113B791E8A5FEFC242EE48
E1EBB351805B536D044643FBB44F5F9BC8E44CDCB94CDA6E10C8FF496E530785
F71D6618A92F0F4156B7490CA9B2B1B4ED7B0D7BDD3B01A1A493EEAE2D2F5AAD
4F4111C92C199DAD250A7B9E25F5DE5F6C986723E6ED3315ACAF6AF5EAB716F6
08451041990AC546BA6A36930C42194F164B774A6521BD2DF06573EC663C3F30
1D0203E2BD6F5B0DE0851DBE74C69D1667F7AA5E5B3707A18C02CFF7CD88A835
4A4BE15F6364D8B2A55041F1888F708B929A6DE941204F37FE95113977FA4969
EBF973D37BE353D2380BC84922AF1C4DA52CE712AAAA0FC38A42C5CF36FDD694
E1830E19A8E116B7CF56F4EA5F26C2FE08AE7004FBCFDA5650E2A6F2FB2A3F96
E7CEFD7AE1D4169A37DE6119806E10DBCAC6D67D32AEB662FB827FDDB367ACB0
0F9951D2A42DCDF006A4C02B8D2B0D7939D5C3DABA9A28A23AE450A6CC9C39CA
7A47CA1DB46C2FA1AD5E04A9FA63A1713E7B6A8F79AC724A8AC63FD98FD52449
E2718AB593CF82A5DECCA30BAA3A4B5CE0152B8A9D68B1FD64665D7F1161123D
E639BEDD3F356D3159F9823A40AE9BB4E16C57C03CB82B3F896BBCA05C040D06
3E4E40F91E0192D780EF5C386B01F076EFA584965A31A99F20E998242CCAD5B1
D3773D4BDCDD188031E7D00A98112CEB468C8893D26E60BBF8002A43E920D44D
A0A2EF9C3D933EE163A5C433E1C6BA9073C40EEB9A16EBF1C8FEA010D587F80C
EACCD2A4DADE67C76B8B5547742E0A06B1E47E450402EEE3DF8D4B01E216DAD3
FE9D126826EC2DEB87B64A001DB9CE0065B4440F46558857CEF5470999F6B3A6
17F59110A2C02B374671CAAB374E9413E32156139B39C3D54E613D1725EDCD43
7FD264FC982CEF3D8AEC90AF13B5F35B812EEF80029824654F1AA2450D3BC1DB
E5D9D9AA5A228429EEBB58E6B2785DCEF1DFD5D7DD74FFF4814CD9B28BE77095
221702FB8114D22F0AA98FA76B4F9B0BB11244BA5CE2D533891FE20A39605C92
08676150DB464E00C96EAE5A39DF879D8EC86DD5CBC285E67B5040D771B36F12
5582F0EFA67887D10647FBC95C888433F9846AB8D0AE9805FF7654ABAB07748A
2A39C010F5511D13C209B6CC8C59791338B058F3DBCEF3116F6F1FFECAEAAC7C
D0D42619E95BCB97A856358D4FDCE0CE3964A38D6DB1988E695793367F06AF21
D1BE34825BF379A627DF70CADDCA5914FC9B7B8DCBA796C306F32E1BBDD57DE6
CCBC235568B5339DF2BC4A17C1CA0B3D1D5EF88855413E7EC0893CFB58E29B85
F3979C805A26143BB8CA5A9C07D622029ECC2034074343ED2E8030D46D6A81CB
7DA4D13F28967543B28B7EE87294D2AB38CD616D269504032E924B75E90F9E6C
1700B0D29AB5A8E195115CD7BE0E67687980FE92A22D4E88ACD552DAF91CA00B
750A737C63E1FDF6BA283E7DA62045A3F3EB95B89194ECB9A42F219B263C595C
25A5ACDAA6ABA08244BE7886D6013E71C89DBCC6129635CB7C0677963DC75E68
1B45BD97585DDE24B91080ACD10C1F1A186AA6F36EEE710165253F6F1FE6930D
BB028EB1255C28B301912DD3D8ECA29BCF373B00DF38719F2DFC3043D0412D35
2B8B1C4660D23A0DC868C6CFCC9E979A15642EBFC1C9A913BC3B459C494D082E
53D23EE681E4A5AE44DF7C99DC171817F154F4620E3D6FEB5D9337E9004FB796
34D477A3EB341EA95F40EE7B06B0B33A8FD7A096378CA1D0F7DDC4DEABBC8ACA
CE5082E467F29BA94E9C593E588FF473DC2CF9A4DC312500135F29963A9E4004
C042A47B64B3F9ED186A6B2EE09B216A36346CF5E8F8721B10CD41E8A472310F
263725A7AA1ADB3FA770CF22A5981E3AC5552079BEF813CEFFAA1099873922AD
552C6D30366E6F5E2E6190C3A2A4C11F588A1C7F72B80DD9C41B301B292EFA78
D34B628E6DB858E84630C97F1D22D9AEE1A43D87C278398E5A0C5ABD81AF4C09
984B0B56E88B696DAF486379793B91122D25A68754B08B9F146C3DF045ED20C5
56316764D8B0ADD350E618665966AEB0AB0159DE286F0521C03C0FC94CB0226A
A2C0B02D010916DF10B2618E936BE409AC0BBCA917F3273BD8D515C07A694AA2
C0A3E4B661A566F30F074C97AD85DA9D2C3A8473DCE7F9C525C06C621AECC3AE
C79108918C925B9C0D65658B4C11AC2E62A7850FFC2397A96AB26D8425AB400B
67D1914D95B4161D7E47B9FCB0FBB2493B52CD906CC6B2B7331D6FB77443DFAA
AE3EDD2D1915F06652C555DDC1C5F0A262B791BC0945899247E92390E3150072
D899C51D844DA928BBC737C28B54B5B71AFA610D5944F38ADDF9A0964D70C16C
390DD2D9113275345C3F7173A85C5EEA7CB0B359C8CF28F1126A30213AB44EBC
F40052549AAB3B7AFE9FBE526BDD445A5274EC2A322C802770D4DA5EDD00190E
AC88587A1CE54021543330C771EFA1E65A36E5D90DB6161D99C92FAF34222742
5B7354580327B981E54E491366B3C317F1EC8C377581B73C1AA2F992C65EC402
10B02645F024F2F6BE33DBE53CB46704628C00552276940B4BDE8BF5A0017C1F
789A5E1CC9AB4D4EE1A3A18BDF22EAAA457D5A024BED19160E796ED99B5F82AB
D2D17933DD2A6E6B0711415F83358F98C2AF7D9AA825BE430EFB96B436F06FE2
119D8AF2A2290D04A85B82F07F315F180B1725219DC3F77C5C57968FAE08D03A
8E5016525D50AE5EBBA61734B2BB7F236CFC9B0C3D209B05E8FB22993B3923D2
3C15BF486896FE3B398AE560DA86434D4DE01AF1E7A68BF85376D3C0E8D0CB81
93801D5A33FC9BF82C15A698DF89DB01166CC067EC637BB2E4A28B8E63950558
12B50B067502D4BF14AE165720FD7AE5BF9B11674C501A36455343EF9BB52CBE
DB80675A75282ABFBE5868A29E4A72C6DF05988162F0F9102828DED352542600
3522DDBA25EDA008D4CD6651EFFB3C7233F18680B9AF0AE25A96F4508222FA88
1FF53E3406C0135D21B99B986527EA3DACE7D44011A439ECA3E7D7A78FB70C4F
13B5042DD540DDC36BFEC5F2A8DBE04EF457ED6FCD1FE648FAD5D9CA965E3921
9D4D5B7DB20F5344037384B36372980D613F50CD8E4BC5A115E2C5C5479B0824
B87C47EEBE7B4D7FFBB977A8CDB8AB8FD92E8E45D0CB167BEB8857F02844C8F0
868369A32C73E53CECB3F8DC16C3377A4DAE834D84422EF7459DC1146671DB15
7C352CF5D668B37FA273AD93668F3015B78B5C1A1B56342AFE9239B8A7550212
46B6F5140968B154D375AC78AD1F5E86D4224FD910004FE50719E10D2EC81F41
370286A509D225579FAA0D7363D8DDCA3FA90B6F29BEC7434AA3E469BFF35C5A
12593334E29F1BF4D62BB910E63C238762366AA97B01160BEEC44BB2EDFB7BFE
37BF311A85626C693F6C331DE5CCC5D42330E221417720CB5C4FFC0A1841E6DB
BB996B8E547CE39EF0E85B7E02315F8232B75A0B20F2DED356DAE0B109324D15
A0612A7F132FCAB61387C41E9EC3D8B38059E8CC3085B31B634156DB9BCDA332
B3B4416659049ECF7D9EFD8D8343E00B8BF0BA6742BB83F7C337E382B5499035
340294E35AA4EFA650CEFE8E82912331C974AEA6788D698AE08F163954A6FD73
235CAB0BEE1CE0851AC8BC9F02EC308C99A8A72453227EFB173C6B1B86BE50F6
8FF1A2B0044EF3A36B4ED4F7EDBB6C2CCB86355984ACEB159155BE637DCE5849
9438D689408EA169FFA5A77722E5FBBD2470258F37FF6FD2C1DE67D23FB5784E
B7B027C428CE9B2A856E193FB6866C58C6FE84D5769C372D589078C5A58DF130
CD5F41A5AC360C4CC7F79C10FFFD5DF0F487ED245BB4615191BDDB849A43AD48
691C2A47DF0567BA94D8B9F098FC05A1C7CC0DEE8D2DA2562F798ECC64FF3A7B
96AA271E594B5A7034CD0CD8B8D5BBE865B7C01BA69CE1B32EC3CBF5BE47F90A
06CC082F4EE295542B24C365166F0160DE115D50BE30DC224E0A64A0821E37C2
C62187154F41BAF872AEF7944E603B63ABAE0A351858788C77352540E0D7F534
F81AED7BE45EC048DFDEE21895D803301EB63A3E98DF0784FD8199EF056F99A3
39B5BFB9A1FE88C0CE71AC16E4B64B4C12BA3179A9042796F7470338240E4432
4EBC3AB047ADAA952563C6CD2705E89853D5D3B1E5D4B3EC3864FC
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%Version: 001.5
%Copyright: My calligraphic handwriting with fancy serifs. Done in
%Copyright: April 2004. Added some glyphs and improved kerning in
%Copyright: December 2005.
%Copyright:
%Copyright: Created by Christian Gollwitzer (Auriocus) with FontForge
%Copyright: 1.0
% Generated by FontForge 20061014 (http://fontforge.sf.net/)
FontDirectory/AuriocusKalligraphicus known{/AuriocusKalligraphicus findfont dup/UniqueID known{dup
/UniqueID get 4242285 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
12 dict begin
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
/FontName /AuriocusKalligraphicus def
/FontBBox {-237 -325 969 1029 }readonly def
/XUID [1021 352 772172551 5208529] def
/PaintType 0 def
/FontInfo 11 dict dup begin
/version (001.5) readonly def
/Notice (My calligraphic handwriting with fancy serifs. Done in April 2004. Added some glyphs and improved kerning in December 2005.\012\012Created by Christian Gollwitzer \050Auriocus\051 with FontForge 1.0 \012) readonly def
% My calligraphic handwriting with fancy serifs. Done in April 2004. Added some glyphs and improved kerning in December 2005.
%
% Created by Christian Gollwitzer (Auriocus) with FontForge 1.0
/FullName (Auriocus Kalligraphicus) readonly def
/FamilyName (AuriocusKalligraphicus) readonly def
/Weight (Medium) readonly def
/FSType 0 def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
/ascent 720 def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 40 /parenleft put
dup 41 /parenright put
dup 44 /comma put
dup 45 /hyphen put
dup 58 /colon put
dup 60 /less put
dup 61 /equal put
dup 62 /greater put
dup 91 /bracketleft put
dup 93 /bracketright put
dup 102 /f put
dup 115 /s put
dup 123 /braceleft put
dup 124 /bar put
dup 125 /braceright put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CE30585F628C5960F4BA7A0E78D80B
EA23A0384400281199F7528220D2F21D031A35321A044226094B6ED6DB52413E
0BC02D4EAA6BB6C3D02F5D5E4983DFAE1209911A8DDC998656E07B4EEAEF13DE
50FAB8A7D9346FDBBBF1EAF791BE7E3B4BBA8D381C5C32DCB4436D5834A17B60
26188D4C558BC1ED012EA8DED9DF22A29EAE8673C46D0CFF7F5EB4080882EF91
2FF746A93A7B15CFC25341DED2CC7041F5D2FFCE348F17C86124EDBD259F3D7A
A299B032DF19B1C8C6EF386EFC8CA15C863CCD701D6A69E606C01B0D7D7D6E1D
3F5552EFC38CF93F4D2E8253A9DFECDADD4DF59D7AFC1DD6C8ADFABF89B1A2C8
71B75E65B25BE586BCA59EF962F6418D04C990CE8532F7B4EC6E6CEB49CEFE2A
7356362D82C2A0C64C2C91A27ADCA6BB6BBB3AB84CC458CDF65720BCF471A857
D8C8CE698FBC341C6FC2E3676AE48BE30EA42851F96CDE40AAF42A95F64AC28B
966C296B247531501E497B3E7CEF0AA7C97DB8AB0C55F36D3C74C4A342A6F9CF
A20730A0601B09C7C142CAFBCB9597EF488DB90BAB873D1B4CD4F422FF56C37F
ACA36DDD5D088E1673B1DCD365F6E0FE077FDBF7448D3AD5AA1D8828476B667A
B689E779F572FFC125A8A19DE5FD01BAD8DDF51A1C2C42F1BFF30469641A03C5
F3B9DD960B5DB3C9C7668A18D5639907D97B68E0DEDFF9A63848DBF89B8EDEA4
C6334E5E0DF3E72AC4FBB6CF5CA4FBE07CE7BCAF07282F20567FD48A0C6A5BF1
14F463F3179CF32A888B31E32472AB96B0F6FCC8F0FFBB4A54F69E626B72D79C
FE3582B3F55C1C3B31A5A86FF5963BDC3390360C1BECC2601768B62E935B7948
8C1755FA32451AE380111909308330C21EA5D862F3A85AC5A3144707DA15F877
0B9202A29F8ACC1E9C8FFEBB769F827F13DC3985747B27B9288D1B9060BCCBBC
2D274539B2F0C15074ACB66DBDF32470D6B4E6AD902DC41F77BDB42E7E80234E
BF2E7C62E6C882DA9DFB7BB0E9B0B31EF07035987877FBE6E7C2F2701FC08432
481524B2DDE4C7ABC2558772217B7DCE425314F5527E5C8B774A6C0335BFAAD8
03C9800E90E46543DD34005DD1E0C0107A2832B5F5C449B7D9EA3AD70A496CF7
AF308F5696A3C5419063B81AFD094A2355CB65C26B99132D553F21D963C0E735
42CC9A5285823E99B975FC09D8A447820A53702E6205FFA08B6800620A2CFF08
2750CF253CB136751300AB9F9341255A9BA1329ED5A0A1C947CAD5A87BB43F68
7E2003D74E707191EB5B8FBE38DA8151713FBFF1F5AF68E2540408A715C416D0
0ACCB235B716DD940A25ACF8AB1444181883A40FFBD0C338264E42746A4FC6BF
C290D00081F60586C124C0DEA18AF74F6FA4FD574F36AA2E64C6E1AD1A4021E7
D53A9377EBEFC6206D372675CF43235722B50C78881F390A0F59258E4C768AC0
134A614BFB94C297F0B1A982A5CE8765E2681E64B8D84A7CD7504E58C360B459
D25F8802020152E5FE51543C5E421C449E9093873150FC6E903E8E0A2D4CB9CD
1CEE0FBECE6DEE1FF7CEE32749C91435CB06331F25F4F0DEBA6297C79D1328CC
B4CE026622460A1EFD5A50F83C296A6210B859237D7F5218A3AE67A8BDEDDBF2
F325F764F1EB870F21C9E55F66AA6BCF8680F5ECC44BAEB2FC45360FBD37C170
E37F4EDB7BFA4BA312D36DB126F3F762B9AD271E681133A39732C72F4CD00E82
6B2CA80AEBCAC8DAF08B5F99CD7C64135AF75C84EC1B33C8D552AEEDEA05C43C
ADCEEC62CDC875177363DC60813AB953B86879DFE1185BF04B4E527C706E1142
59F997BAE0A75988ADBC792656B858C0919BAA073453B24BA18020551168A47E
D789C2AD9AB8C8FB7EA2F8C7D7678505738399691E13A39724DB49888E5D912D
C57EEC67E0DF4748B39BBE76D32933BFB3185C3972FFB25FA338E60FB97E9B4C
0A2D50833E3CE505A453E686035C30F5D3ED829E776712B0C615569D762EDD8A
41EE4E5C91A0E48EC55BDAAF013638C4670221772B99FBBA9D68F365A1277FCC
81ACDD099D6CB6B588219807BFA4287D199FE70B61320E45165BF341A972D158
6EB22BBF49E6EE68930925AEB60A25ACF8AB1444181E43B81AB7A9DE66411EC1
1874E8F570E04190A053666A8B2AF034C738EFD85CDB54556BC6C7FF68FBD045
C766F63AA2D015BF620BA53B1985060B8735BBAF50F1EB2E1E458010F9E338AF
54166E27780D54AD11691AE045E850DA1DC3B6C24BED7652351676B60003113C
2E126D63B329E4FF36D1D478E7E56F6BBD4476127E6F2E34212A72336D6DAAB7
32B3EC3376BD946A169FB710C91AFC97674F2843FB709E08E283462DDB1DBEA1
75D7E82D2846B4F9E855BCB5A68A509C2B7DD27D8A995E5405EB5449AD8CCDFE
6615E39270C3A6F455FBA16353A2CD596FF217E9DC7CF6ED25978A39A0012C33
FB272A233E9EFAD5D5A9DD14965D4F6C75C84A59E4E75BA397998E519B70C367
0D8B0B89C65A9D8D2FEE876EC79521622318BB6960F7588E6392FC1E2C67761D
0D301AC007CC53D1D606A525FFF9B82676B7EAA7055CB375591EC4D3F37E7B7E
75DCDC8A7A2BBFD32252F00C260C61B660C0AA450558474AA95A6AA5285E1D91
B95D756569BB1CF2627F31E8858BFE5D4601A8834048C2F40563527AC4DB5221
EEF186188AB4AC636430D496E772B134E967A87C75DDB0CF6D266873087FACB9
89417DDDC86353DF7DB7650E5A269FB01D9005A3A2C1225FF0F42C625C70936D
03764A529AF1CCBD3B571C3A1408E009CA7E91A4FCB9BCD2AD4E0553478DB64A
9868CE25F7F4DE35466B46A08AFF4DDC3E1AE7E157D0B060877EE5BF81CFDAF1
7C6D14352B635755B44F2FE0E26DFBE41679C989CCC086CAA9FDC9FE5B146153
A3765EB54A0CCC6F3C7D0D0F8F391FA693DAB3368A64C98FAB5CE98D1F6DC7D1
44CD15B5350AEB598CCAAEB5DBF6D6DA7CF63EAE1CDEBED6E6EDCAC55F6938DD
18C713F89A456304536E4FFB3F4D84198A9E10E11012356AEC52AF15E6F603DC
FBAA636E4A36DE74CB5681B661895B7CB1149DC7E86C9C21993D1E3D1F18AD44
0268C0509EB12B15E3FB817C7C68A5AFCE832F12010094DC211CB2CB94A27524
A4C2516A81623EAFA7E8C3BCA79544B1A2F756D81ACAE235A58C64D8D7CBFCEB
48AC8039D5471FD6CA8D23CA52C667FF8F76A79F88BD4C1B6B51FA0AF37BD60B
104C2805488298DEF3FCFB7CCE86EE27E881F92873624984CC26B6785880BC6C
811D416D3D241E6E1F260DAD2B20FD614EC1BB1E86BC855FB26CF97E86543F85
35CD77C6C7338141134A1767C173C6DCBF776CB6B0E7FCFEC4BDB0D1D462A02E
58271AAE4609F63F5769FBE23CA6E81B848B36310D30657C9BA48F83C092D5D4
237EE296F30437D81F226510EBF89944E1592B68687977789BE4C8C753C4A650
7D29C2DFC5BE7D537F9884A1B726C0EEEF014B842B599EE91D1C073AA53F3678
37381578AD3A9219C4939BAAD44192B4725E5774372A39F5BE217A815AE85C56
C97C347BE7F0AE7201F6E31EF557FDFA2A73486C829264B058D39F0BE68BFDC0
1EF19C34C9A6885403D18C17AE5C262200919A108CCF28ADD9B2582CF6C31787
00E56D15B5052873B96E9DEF3EAEC6D5B9A045F9280D79AC9E0E0857D53E36D8
081D645083CB8C992985DB99D9BD2FF16DF4B25B62F3A47B378A341378AB1E9A
AA8811247FF99DB5F0EB05D6721391E6087C57E8E85B7916A560F41BA87B4E08
CAE59E8303C56509CEE4C3952CDA40F8673345263FB59BF0D7FD22BB800A96B2
7229643FD09507BDF345201376AFE24ED8E855C8EC0A4F1B4D11DF91C6F3D21F
BBAAD00FDDDABFD9997F399B5F4372E6BA89FE4E63D756C79DABC7B7F74B98D7
388AAE403149E46F78BB6AC81DE809BFBCF8A569CFE3CB51371BD3F69A70793D
051FFF5B94C59304876FAEF8A9213C866648B75738A5C8191EE933637A398B71
B3962B53ADED366BD57798F0A499C68E97E7D0CCD7AD7246FAB1180515271648
0C0984BA13A8433ADBD6274AE855754BC800985A57640B2B6105B2D2C996F6DF
6D5AB22364382116A593A43A2564A451C9C2B5E8FF8F32FB6D3C67E6A4D86462
98E229C517E89E253C62F7567D31B488B661F8C45EBD2FB0F0EE1D4A21068725
C8B06B4FDF37FC4C6C7ED97BD15B1763422CB08A2754EF68A6F45AEB7201BBCD
ED53FC161D391E60C536BDB9FEB9D7FD20677DC4F398E82228CEB92CE0B938E8
D749527468A9A8F373D160DD28034D6CB673381BC9C0F050085274ADB56BAAF1
93211E48D1B82FECDB18242FBDEAF27C46F87AC86B449D3236C6792C98D19049
A4D209E48A8C35D53CA5448E61FD7AB85D69EF376F50AF253F652F3DCC444580
71698F9D8B968FCFEFD7B94DFC5FBFA569DB2DEE9C6F9B59FE8E849CF8F7314A
FA6168B74E2261A1B0741D368D2D66F5AA22A21AFC1C22AC891A13A81C3D4798
55407B719AC4CFD53E315CAC67DCCC00076D10EBBB44DF439E590EF307E3E82D
817756FA99164500A4FF96C938775DDAFF6F38DA8B5AACB10C1E4E91CA5F7A54
D5F433E3C4634AEA50366B8FD7766C8D058CEB08DBC89FDCFE82943233107323
6EDD9C3FF5933ACD2938305FB7CDEFEC635C4E3E11848E1DFB99333565B6755C
FECD5A7D6AFBE3357B27903484CD761C708302BEF4ABA0604CADADFCE6247669
F639292716CB18F9F1704B5B90966A67F84AED0E31A74143E7C8E8082E90DBFE
87968918000FCCC4BBB3D0F0A77E1454F81E640D484E5F57C00B1336A8F61DE8
919B9F5A59FB70839530DFDD8B9C9935E7B787F601DADCC81385EBE082F94F5F
401CE18E37E72D710F5E78D3661C1ED935B5F3C838C5D6E0759370339A0297AC
32017884DF60593D4EE166A88EF1032E139530F126E04969167E33E7B7B966EA
B46B72FFD337D62DEA0EECDAC0ACC8C1B258E13EAD49D36116364F6521EB538A
E28E6235227D5C3994BDF143323DFF913D8D5F9B31D94A995E77D369B625EAF0
B5D3F2BD829F18A73BA4F6BDA48AEF16E1AB71D7CE24EA38F223F1DC6C82984F
684FAC254DBF9402FA697944DB0E2391A4398F807B63BE700B1AFB79F0AF65F7
245D7C43E991B821CBFD12998A51229EDEA18F865240EB8798E151CFFBFDD570
C4C889FF6E06E89C0A4DD63522941977A50542DEBFE49BE6CC438036AED93D9A
FE1019705615D9521283139769F56B466B95CF4D412DF23AB5FBCF21181170BB
05CC2CAF62830C2C50EFD34C4EF05B458A7F0E455510C6AB9398D0660C89E168
5C610486617764E313967A0B57292667588D0A60A045AE5775EFA12499412813
AC5E94569BAF36B58970E90CC6E9E86B18FA27EFADE71958B056020FAA6FFBE7
DDD4DBC0EAF83761AD4E89C36AC72560140421800FFBFCF4372B123AB0E9FF5A
8773FAF9ABED1306F7C5D34E2B7D5A9E4FF5703279B1419264F16AD68DAB440F
5DF9902E8025EFB02CF86B2C5F4EFEC4C0CBE41CAE0129E9F3CB9D1D32F1075D
820217FF657475174496299457BECACD36404D977C4E54294390E2C94CCC44A3
8C2CE2AC5E22AB57C488C22AFB8EDB02B3CDA24BE5B94F4D4C0FAB79CD0D3E7F
8A3B5949B004C475B44AF584CD94B6036638EBE33CB1F047DFC73CBEF771A594
437E6E1C6B0F15FB3102DB7A38D2B930BCFF5A9055C76EF4ED2A397E30973F13
C9C94B941C8D71814BE7FEE42E6D1EB7644C10A722A014371DC1382EEDD1FADF
C9657622FE1DB7AD97EB59EA5EEEBBC6332449D33F89196645962942DEBDD82A
0C4A86F033DD8799CB81ACDD096869581E002A8CC83AD69B46600CCD7201BD9A
578AA45A71F49C3A2EF3D7FC39994B3930C92AB60263C26A3F863C255B50B200
37BB29949C5D3BAF6170A01E13666A84DFEBC5A5DC04BFB1D49BF5BEB1066113
3F4EDB0BC61B5534D7D828A053B63A3FD4CB6B69F9D538B0B8EB1F74EF96BF93
802DB51EC3DF27141481D4FDC4FCD4B1697443A99FFA4491F2B85D31FA193A85
3245CE402700E4F6522AC928BB0867AA56FADF3E62F47157E929BFF034448EAE
1F2DE0E580EDC77556593D17E7D19E7444F69437431B1A29274230E39961C7BE
EFEB6CBD35AF77B9BF050E361D4276B87A5C192775C12A3B9A751A0D375757D9
5AE364394FC25E6E0D02C684076FC96647F5024D51CD78D79C802EEABBCA93CB
F9681CB0838C9B2131051DBED189118B9279A11243BF04609DDC15A3C1C57D72
0730A217C1FC0D4C67888FE582FB2CA30C3E1F7947C49168E23A66FDA1F9EDE6
A6FCC1F86C61946D89C85F0D768464C63A420C92EE326D2E957543E35FF59A53
F05C0062625D37824DEA62B249FC1C0B2F40E73B6362371674CD8D17C4A126C4
152A6B22731A0DB00B7EF2C63EA1BFE05E7FF28BC45DE57386BFFA72149D67F6
5FA98B9F43898794D8792342D6C861364C05B4AC6855C60720578B8ED32F4227
83D5602F4D849A35086F959488AC0031B9FC0A4B95BBF5375153E1ADFD4D5390
6402CC460D1FA83F9E61A9D43ECA9E71EFA883E06051FC0C11F538B97D63BE12
43A16092815AD6DAF18FBB0A7D4CC562F0A29850DD305BCC772176173B89D7A2
2B3EE44ADC0B596B2D9EF2B48C4C34C41B3DE4C5E5E4EECC3EA26C7A414A936E
EE3CA5F93104686A6A1FDF80DE68756A32B4EA54F00BE8FEA009FAC04B417D6F
52C94D471AF5636E4360AC38465311BF5264D7C65DC09CB28060D70D4C60F8B3
03EEAEE0AF8CD14ACC235797329DD4B3F65FA844FB5A3D025ABFDE1914A48642
849EA4E80D580A062FFBA198B5E90EE7AD576CADC882AB525FF87D3331B3A605
58DBF29E7831B40F8B506829FBD19A580619E00C432055FDD36B3A3C2971FB15
25EAD3E5302D64077F685F1BA232011ABEA0161845F8C8C9AD8E09BE171DA84A
ECA7D7F1D380D4DE96A8AE7C7C87A24EF840E54ADCDC4A00D21DA33FA56E1245
4F517FF515D115A58C49951499BF23E85C86CF1E26DEFE5DB3747D637463CA39
A5E3805C5D80CB63F88D3CEA897173062D2C9F76AA743021D6368578618E9BF3
E943162AC8F1CEBEACBF36C46E4B7265C997FF9B2B54E3181A588B551C4474B9
4AC25B6020FFA17C3511297D6645C75659BC9AB2F84FAAC9E4F8513713182910
E3D457653B6EF3E43985E7FF5E44AE87B6FB26134342D053A781E0DBA2EF48A5
F395C010DD1BB1DA8E4325178A550EE807656FAECF689AC9ADAB01E7FA804D9B
72297D7E125AC2385F967F0D75249179BB2E4D08812993C9B30A0B3637010466
A37D810C55E1656A328076EDCFA012BE6263895F3DE8DCF57A863A507CAE3D3D
F91E6817BE240DE0D51E1A276E479CE3372ED28D0E58C886F9EC8A001727ACB6
23419646D3A64AC9DDC70ACA33F1D74236B8B65613341C0436194F1910DB2F7B
B09E36E2C25639F14FFF52C10EBBDD60FE3BE9CC8EDC2F8B60B9B28913F576CE
1009418235F554AA3BDE4557C1632416DA2B2C8DA86BDEB7023DCFB475EEB242
EB1ACFAD9FE379E06F558755D6905BF90A54F72850FDA56494BCE616B457E20A
706BC8BCB5039DF8F38082D78A8C6F79BCA9DB89E5EBB0A187FCF8AEE3963246
A74852A87F0DD819721FF0F6356A61FE73B7EFAB168CFA5110E524BA4EE88A73
A3C38F5144FC8785517C411C1C599BF939AE66A7A32F5007F7E9CC4419C83149
F1258B10A7EF41D985F7EB3E3C8004229D81601C90055F974B67FC1205C57462
DD7EB489A8F9A12D71D112FB2823E76A606C33510D927E91B9C8812B52B037E8
F5B82FA6C8ABDA49A70919E9A025C40781984131C72588AC92ACA83ADE2A99BD
30363A00961160B9C6CB7E00D085DA5DEAC5013CC171FA7777D224EBB8961BA5
8272022975A08BC4AD1C4E3AA13295473360E7BD879965B53B849DD2A09DA894
0F169985B68321F541E03237972F6F1BB2138FA39ACEBC23F7CE6C5B27F4D575
7A057586ACB5553B6FD2F7823F059BA46993AD6F1FB1E89FC787AACCF51D91A3
50C72C841E65A7A9C151F601FC335943F1CAA69C6F8342222285F070DCCE0F61
0A2A2F8B7B4C3077D40345CB8EF31B4AF52EB33C4DCBD6A97FD750BE182631D7
A820BA6B994F437235A3267D56E6C5DCD00E07A71ED7505E255402EA14E0F075
500D2DF8B75C273D18F46C617E4689E8A2771EB1976B77357EED432374DC9F0E
5A934E6F4857F5FA09051BC9F47E5453175A60F71F522159E2895B0D06328068
D5AFB2D091053D4DB599C047C396D7C2E8F76E006C5AB437D9C0F815F0E47534
A7335898B86A43C51D4DB480AEA24BEDE3B977A90296464C33CADD3F6A18AC90
FF7A7B849AB9FD1549386DF823459D6692713B37F813DA9D5BC0BF68321A460E
2E1B3C14A978D5DF1C3AF852746198E6CF3425A7E380784825C1B394E3FF33A2
DF8BB3DABAAA2559A4A74859C13B0838C058532A62F8B1A9FFD880E1923E566D
A095BED39BCCF5711A804DACBE692CBB98F27C197AF5056D3CAC8178B4604CDE
B9D70D194852BE996DE96235BC0E2942E648BAC745A3A9B03E9C019636DD3AF1
3D2E590314359C460B9AEC86692E2E36C9A2DD2695630F211DAB0BCE739C9721
8E51070951066520A4FBE18EA1D0E5E82F6C3E52C1256DEACF95F7BDE5B8EDC2
53F2BB6207AE1EDF185BCFDCEC17FCAE5CB0D3754E82C8E92D648C3429F6AAA8
AE42D9242E2567FB138912221F974BF5F69E7F1CB5339CD518F8EC897D2298D3
78C509DC453BE01958A0C5E4CC187EB1E72B48E66271BAFC18939D9ADF577C4F
F9B72CA06FF9A1C9870A72AAEEC35FBE16756AF35A6CE10AE6B6951D9BFC0DD4
ADCB8E476E6C3443A3167AC74CF8A84C223DB9121273F58F066C120C9DF0BADC
1FDDEBA0AD17DDA8358E783EF3EF6B690A42D7564B8B0380AFCC4DFC02664741
0F7CB4D13B4B6EA4090DCC3253DE8A2016777AD145E25AFF0D4F144EDD9AA44E
6569589982A4534588B87C269D31418E55B2B75B88A01FF3873AAF0DC6CA5763
94678F694D05FCB0B83222C4F343CA3A92022FC2728BC8E1973C711C41A969C9
AAEA70870B732CCF00C01B2BF1430A12BB67E1B9F4F4EE2EB0724997BDC59D0E
A5C9AE9C7F8F623D68D9CA66B4DE4ACD425405E180BB8D38B4DD94F5F670CC2C
4515B57039BDE45E98CEF3EBA664063B2C58FAB1BE23B3943558FA195B728CA2
9608FAF161C514BCB338213CEEC8EF213B6360ADAACBB775A9CAF778DEADC673
04C6375E5699C9D82F98F8FDFE27B2A77C4A81385AB99DB0AE8A18E8DA3D8D71
45F966C9A4AD9DFFAF424C2F9C33A69149C0789AB0A2B291EE1E150A46C43BB8
66BAD05E782C263219728441A279DF5B052616CECB85AE157A7DF573048F70E5
5544C05B6D4E803CF36044FF28C09EB720FDCD7F51759AE827C56005852283C0
889F3DDB06DC533F30133189A54209CC8B8CBE586C4618591753C22DB6968D2E
F926C2E58B1C0CD519E62C202D4CCDA001A06ADAE88D1F9B292DEB0A83E195BD
E74E4A2572B168EF5AC3F4B709BDC43402F7BD50F0B1978C984458226F0FAC21
3D5E06EB9B329F977C7CAF80B9E3277B978A33751A0B7D40E1B88B48EAA3072E
DC44E5F080D4E6C5E8222A087B626FFFFB6289DB6BBA9E3D157F8C6F5525DD31
BAAB971188D827CCD12E0D667F5AA58932D4955AEF6C04A4008DE155B5696A07
29F01D0C2D802364ECA7601C42D249F71DC2B512C1B3670271E0DF1A20FD9597
0BB8AD719EEAE7137EDC4EB16550A148C0E4C8D194E688EDAE32D603221DFEB5
666AF68CD2C2650E82EF1D4951A42A5AB700990CCCC07E371FFC858D16C065A8
ACFA16EF324981F13C050CC4B8CBF7BC33372F11369332E979437745EB4CEF20
386898E81B26C6329EA5E5A94171E8F7914DE767FF178C332DCE42641194252D
51EB0B709FA926EADCBBDBEA49AFAA06418E43A439A9685101D43375393FA134
45EA477EC95CA9A1522704EC4AF32D6EF64885E51E10B2690F19260A735BC2C2
28CB96157033929277E0C7B15D66F63CC7BD392332EFF1521F4EA6C644E8A8D8
3ED44DBCFB615AC6CBBABA226373631B6402CD217799BE999765AF29C1360831
C8BBA63895B9B9DCD468179088FC06620861CBA35FC285EBDD5C9116B1DEEF97
A32508D7C23D4BAFFCEF6083DB513DBC86541EC57522B177EAE8555346A01BC9
68DD46428FE31E98EE4794ABCCC67240F0094B80C289FA80142290DB722E42FB
76D936E512CFE089E46FC2F4DAFC099A68C93608BA3FDA4394A26F852C84D0CE
D3BB59EAEADDA8C339038DD8B8588430923A193478D45272E8A0120D26B226F6
C4B5202F2C6AE682D36C1BF726B6F05B88D5E353902AF1F3BF85EE50C81F7354
6DFB67B39CC244CE66579B32CE64ACE549A1D666E9FDEB53FC48AC891722EABE
F494DA0B14D9F57B431BECCBFB4F75A4BA5BD22872450D34049F49966FEDFF25
EF327F1069B9A50E405DBE95E60E75D59F2BB6F4394AD94B06AFCCAA9EC573A2
8DC31B692A0C05FB0325C767F3390BA2D8A4881D78D08D38AF79EE1C236B0DAE
691E3BF04465A94700227105C51B49CC134E064C07BE1B81519CBAB4D4327411
9A00F68AF53EF7605D50C5C04CD7297BF51B322469CEE2880135FAA688F54324
7E23F1B31041718EE23DF39F06053A8696AEA40A7F47684A2F460A06F81077C4
C7B3347274A1647E3CA7C3BD4E902ABC113BC8B559CBF3B0684147E3C6F67225
C3476FCD91A3BB13412997E3B8D5E29425E8FC36CE43DA11501AAF3ACC36778C
14F58203294CF88A02F40923CE92656B063D23ACA4711DD48379D7EBCC9C84C6
BB11DEFADBC7F9D7F930CC6B37EC25AEDFD6B89FD1056A251080CAE7E9244D59
2EABCEB1053DF1230AD26B6716E5D2D77C19A52A6F839349E0DB1BC707E4328D
4F262EB057232DCE6AAEE7EBD05F424C7C035B07971CB0DAFA3E1AE731F12840
7DB54968180B0BE27CF06A467A86B08364A0D7F5DE4B5574EE2FCDF6A9FB7806
099AF4D10316A9C79C072734ECB60A0E57CA699D6B6A6469C14DEA42BE9416E3
84242AE700E14E3F14A94DC91B13511AFD46B9BE98AC99BE7B4699020252F1B2
F6ABA89750E598FE90B60F0B45A848B9A325D6F020FDC09A84243B8BF3FECE44
E56951DF70B141E3A31D1B141938D36FFE385A7427C469074A6AD261B1EEE751
9306027B0112437A9D58C0EF71DD2DE475D7123B462D265B8B5E9630776E3CC1
7731CF9376CF6A52C4A514A24D56609CD6AED063F4EFAA7EF43D7C12E78B4CB1
1AEEFF6E853CC271CE4C56CC36DB4C6D8D5C75B32FFDB7D43FB991BD032B4DF0
E7BFF50C309F1BC94C94D464D7786A4C97BF1EEDE62421B65B8EB9A5E8446667
86F1FC806B51D952AD550A9BB9BBE3C951AF2E064200086C168FBA6063279F17
CDACF6871CDAF1303E13258B604F8C1886A3066E66734E8362DB361B0CF687C8
5838B26F1EDF1A7B8648790B6C8B0A93200011A7851378B9E5E6A6C738965534
F66FC43FD9911811205474050FA39B1E70A4B7AFCF67F8D27FB8826DAE51421D
131BA6057DFEEB7B7FB59C4C948468410A5B3A8C2F874D8D357D334B9C240DAF
01D9F656B0136450A03FC9A4CD490F5B2CDE84A0D3C66056119790C7795AD357
9C29308F7719F8F67DC9324EFE7224EC03BE8B327234A47A1D2FC281DD616486
0EF9B40836302BA0D0534D097BF3AF31C791FB6F23BB0986C9F4496CFD01BF82
FA68BE9464C501D81F76652EBED5B47AC95B8C92C771CE958312D6024AC3EC0B
4950E777941FFC1051FE6AC551D88F2C7E8B3E8EDCC94B697520BB7520D638A6
EE7D58A33308D75AF9B74A69183D768BE08145C0E873F7B22D4511FCE645D1DA
FA83B25B67FD641B83734522C7B10BEDE0B7333779A5F3C341E5A4E65F64D89F
584CAF4F4371E2907DD2769B6B38C67DA9A20E666F09010ED1DFB11DF3FF5AE2
219FBE23E856DE21F3B280DEDABACE8C5C302B00956934801ACF10E0EF0F31FB
E220574CE0AF1A3C5D105D8C60C82E9FDA2836D64004CA3357ED249FF36F3F73
C6282F57EE06FE5534F8D56A7F3EC777230722CEA2289742ACB35AA1FAB8C47B
62ADD6BF899CF24D5AB7B0594315D262370131A27C75AC730541E10C45C7CF10
77B4D83ACF47C5EDBC04E385A0E1F0C6F9342215C2F0FBB5EF00EA3A2E99B1F3
6C8B84DD8EAF5A81BA0C322337992EB806449149FBEC020EC952CAC5B3C964CF
8886E268D5EFD92B56B4F54EE4E817EF1C98F3DBDB11243BFE76C14D421236CD
8329635B5C9B570227476D190335BC100DCEDEF996F7DA7824CEC54F4C262723
69557D2A9D14A1E34EC84158ECE81D905C49BAF5A1D43ACFEDBFE8A89E056C6B
4DAFFBB83E6C3E0BD1B8160A4AA386D1CB96271E9EBB802307F6D66EC7325D0F
0BF933C18DE951D519AE3F33A6C7F6D8E26E166DC9B862EAB3B3D42AC99E9911
B62E99812CD921FE3353ECE806645C13208028CC9DB76DA758A33903528D0F88
59CDC693AE6141EFFE4129469F24FC5FEC711B10F5530DA7A096FA25872F3A89
3D34DDB8FC27AB7C822B2B4F04236ADA4726DCA8D7D617C39D38A1D348172131
236271FC2B5C550D1643A9E4EF82E8902BF8400E8ED3583FD9348F73463D0DBF
0F1EA19AE5347D75BF01349B877EF9F3DB70FA5BFCC9AC1201B5773334C1D992
C15B2AD7EF601997EA2BA920FEDC41FB942BDD373D8C9152DD1294D3FFE9B8A3
493E5333877E37C0B92BBBBFC903C337D321861C7E848DB349704AEA48F3325B
5B68CC93BC24A5325966142268904F55EE7C5EC0276454F3BFC4894BFF8407AF
C0B09B3A056ECED28563E44E66C3641B440BD23BFFB07F64A7B827F6383BE2D9
76F4F977C1CEBD3424900919E1BFDD4C9BBD9C35CB454472FBCAE97B7E878F75
14886075FA8465422312E657A0734448464281B47E1F5C5B723FD8E6BEA16029
2892E968848B724CAC6952EBA76AD7CFA9E6534EFE3784890501F3154B148334
E04267AC5C58EA297B29691AF689C22829BC42D504AA22C33C44421C3435CD76
7261CD502D77821FBF2650EFDB9ADFD18C0087C7057C8AF6C1D644AE4BE58AA6
C1F877AB0941166A03A3A183230F8E5858BF9464A45AE4B2254CB3BDB13CC3B4
72AD91CCE96283C6E1144A0D31FC
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
TeXDict begin 31923322 15514138 1000 600 600 (tmpPSFile)
@start /Fa 167[128 4[108 2[102 80[{}3 172.188 /HFBRMI10
rf /Fb 130[58 37 75 7[60 12[73 8[94 1[93 28[100 95 84
1[35 12[100 45 2[54 47 40[{}15 206.625 /AuriocusKalligraphicus
rf end
TeXDict begin
% dvips-unknown
statusdict /setpageparams known { hsize vsize 0 1 statusdict begin {
setpageparams } stopped end } { true } ifelse { statusdict /setpage known
{ hsize vsize 1 statusdict begin { setpage } stopped pop end } if } if
 end
TeXDict begin 1 0 bop 0 TeXcolorgray Black 0 TeXcolorgray
-720 -576 a
 /pssetRGBcolor /setrgbcolor load def /pssetCMYKcolor /setcmykcolor
load def /pssetGraycolor /setgray load def
 -720 -576 a -720 -576 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 -720 -576 a -720
-576 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 -720 -576 a -720 -576 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 -720 -576 a -595 1342
a
tx@Dict begin CP CP translate 1.0  1.0  scale NET  end
 -595 1342 a -568 383 a
tx@Dict begin  { 0.0 -109.8276 } PutCoor PutBegin  end
 -568 383 a Fb([)-57 b([)69 b
Fa(S)76 b Fb(<)-29 b(|)68 b Fa(P)94 b Fb(])-57 b(])68
b Fa(X)-568 383 y
tx@Dict begin  PutEnd  end
 -568 383 a -567 383 a
tx@Dict begin  { 136.57324 -115.51807 } PutCoor PutBegin  end
 -567 383 a -56
x Fb(=)f({)i(\(s,f\))d(|)j(s)f(:)91 b Fa(S)76 b Fb(,)68
b(f)-567 383 y
tx@Dict begin  PutEnd  end
 -567 383 a -567 383 a
tx@Dict begin  { 307.2897 -109.8276 } PutCoor PutBegin  end
 -567 383 a Fb(:)90
b Fa(P)25 b Fb(s)69 b(->)f Fa(X)11 b Fb(})-567 383 y
tx@Dict begin  PutEnd  end

-567 383 a -595 1342 a
tx@Dict begin  CP CP translate 1 1.0 div 1 1.0 div scale NET  end
 -595 1342 a 0 TeXcolorgray 0 TeXcolorgray
eop end

userdict /end-hook known{end-hook}if
%%Trailer
cleartomark countdictstack exch sub { end } repeat restore
%%EOF
